{"ast":null,"code":"import { PluginKey, TextSelection, Selection, SelectionRange, NodeSelection, Plugin } from 'prosemirror-state';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { keydownHandler } from 'prosemirror-keymap';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { Transform } from 'prosemirror-transform'; // Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nvar readFromCache, addToCache; // Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\n\nif (typeof WeakMap != \"undefined\") {\n  var cache = new WeakMap();\n\n  readFromCache = function (key) {\n    return cache.get(key);\n  };\n\n  addToCache = function (key, value) {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  var cache$1 = [],\n      cacheSize = 10,\n      cachePos = 0;\n\n  readFromCache = function (key) {\n    for (var i = 0; i < cache$1.length; i += 2) {\n      if (cache$1[i] == key) {\n        return cache$1[i + 1];\n      }\n    }\n  };\n\n  addToCache = function (key, value) {\n    if (cachePos == cacheSize) {\n      cachePos = 0;\n    }\n\n    cache$1[cachePos++] = key;\n    return cache$1[cachePos++] = value;\n  };\n}\n\nvar Rect = function Rect(left, top, right, bottom) {\n  this.left = left;\n  this.top = top;\n  this.right = right;\n  this.bottom = bottom;\n}; // ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\n\n\nvar TableMap = function TableMap(width, height, map, problems) {\n  // :: number The width of the table\n  this.width = width; // :: number The table's height\n\n  this.height = height; // :: [number] A width * height array with the start position of\n  // the cell covering that part of the table in each slot\n\n  this.map = map; // An optional array of problems (cell overlap or non-rectangular\n  // shape) for the table, used by the table normalizer.\n\n  this.problems = problems;\n}; // :: (number) → Rect\n// Find the dimensions of the cell at the given position.\n\n\nTableMap.prototype.findCell = function findCell(pos) {\n  for (var i = 0; i < this.map.length; i++) {\n    var curPos = this.map[i];\n\n    if (curPos != pos) {\n      continue;\n    }\n\n    var left = i % this.width,\n        top = i / this.width | 0;\n    var right = left + 1,\n        bottom = top + 1;\n\n    for (var j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n      right++;\n    }\n\n    for (var j$1 = 1; bottom < this.height && this.map[i + this.width * j$1] == curPos; j$1++) {\n      bottom++;\n    }\n\n    return new Rect(left, top, right, bottom);\n  }\n\n  throw new RangeError(\"No cell with offset \" + pos + \" found\");\n}; // :: (number) → number\n// Find the left side of the cell at the given position.\n\n\nTableMap.prototype.colCount = function colCount(pos) {\n  for (var i = 0; i < this.map.length; i++) {\n    if (this.map[i] == pos) {\n      return i % this.width;\n    }\n  }\n\n  throw new RangeError(\"No cell with offset \" + pos + \" found\");\n}; // :: (number, string, number) → ?number\n// Find the next cell in the given direction, starting from the cell\n// at `pos`, if any.\n\n\nTableMap.prototype.nextCell = function nextCell(pos, axis, dir) {\n  var ref = this.findCell(pos);\n  var left = ref.left;\n  var right = ref.right;\n  var top = ref.top;\n  var bottom = ref.bottom;\n\n  if (axis == \"horiz\") {\n    if (dir < 0 ? left == 0 : right == this.width) {\n      return null;\n    }\n\n    return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n  } else {\n    if (dir < 0 ? top == 0 : bottom == this.height) {\n      return null;\n    }\n\n    return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n  }\n}; // :: (number, number) → Rect\n// Get the rectangle spanning the two given cells.\n\n\nTableMap.prototype.rectBetween = function rectBetween(a, b) {\n  var ref = this.findCell(a);\n  var leftA = ref.left;\n  var rightA = ref.right;\n  var topA = ref.top;\n  var bottomA = ref.bottom;\n  var ref$1 = this.findCell(b);\n  var leftB = ref$1.left;\n  var rightB = ref$1.right;\n  var topB = ref$1.top;\n  var bottomB = ref$1.bottom;\n  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));\n}; // :: (Rect) → [number]\n// Return the position of all cells that have the top left corner in\n// the given rectangle.\n\n\nTableMap.prototype.cellsInRect = function cellsInRect(rect) {\n  var result = [],\n      seen = {};\n\n  for (var row = rect.top; row < rect.bottom; row++) {\n    for (var col = rect.left; col < rect.right; col++) {\n      var index = row * this.width + col,\n          pos = this.map[index];\n\n      if (seen[pos]) {\n        continue;\n      }\n\n      seen[pos] = true;\n\n      if ((col != rect.left || !col || this.map[index - 1] != pos) && (row != rect.top || !row || this.map[index - this.width] != pos)) {\n        result.push(pos);\n      }\n    }\n  }\n\n  return result;\n}; // :: (number, number, Node) → number\n// Return the position at which the cell at the given row and column\n// starts, or would start, if a cell started there.\n\n\nTableMap.prototype.positionAt = function positionAt(row, col, table) {\n  for (var i = 0, rowStart = 0;; i++) {\n    var rowEnd = rowStart + table.child(i).nodeSize;\n\n    if (i == row) {\n      var index = col + row * this.width,\n          rowEndIndex = (row + 1) * this.width; // Skip past cells from previous rows (via rowspan)\n\n      while (index < rowEndIndex && this.map[index] < rowStart) {\n        index++;\n      }\n\n      return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n    }\n\n    rowStart = rowEnd;\n  }\n}; // :: (Node) → TableMap\n// Find the table map for the given table node.\n\n\nTableMap.get = function get(table) {\n  return readFromCache(table) || addToCache(table, computeMap(table));\n}; // Compute a table map.\n\n\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") {\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  }\n\n  var width = findWidth(table),\n      height = table.childCount;\n  var map = [],\n      mapPos = 0,\n      problems = null,\n      colWidths = [];\n\n  for (var i = 0, e = width * height; i < e; i++) {\n    map[i] = 0;\n  }\n\n  for (var row = 0, pos = 0; row < height; row++) {\n    var rowNode = table.child(row);\n    pos++;\n\n    for (var i$1 = 0;; i$1++) {\n      while (mapPos < map.length && map[mapPos] != 0) {\n        mapPos++;\n      }\n\n      if (i$1 == rowNode.childCount) {\n        break;\n      }\n\n      var cellNode = rowNode.child(i$1);\n      var ref = cellNode.attrs;\n      var colspan = ref.colspan;\n      var rowspan = ref.rowspan;\n      var colwidth = ref.colwidth;\n\n      for (var h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos: pos,\n            n: rowspan - h\n          });\n          break;\n        }\n\n        var start = mapPos + h * width;\n\n        for (var w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) {\n            map[start + w] = pos;\n          } else {\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row: row,\n              pos: pos,\n              n: colspan - w\n            });\n          }\n\n          var colW = colwidth && colwidth[w];\n\n          if (colW) {\n            var widthIndex = (start + w) % width * 2,\n                prev = colWidths[widthIndex];\n\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n\n    var expectedPos = (row + 1) * width,\n        missing = 0;\n\n    while (mapPos < expectedPos) {\n      if (map[mapPos++] == 0) {\n        missing++;\n      }\n    }\n\n    if (missing) {\n      (problems || (problems = [])).push({\n        type: \"missing\",\n        row: row,\n        n: missing\n      });\n    }\n\n    pos++;\n  }\n\n  var tableMap = new TableMap(width, height, map, problems),\n      badWidths = false; // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n\n  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2) {\n    if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) {\n      badWidths = true;\n    }\n  }\n\n  if (badWidths) {\n    findBadColWidths(tableMap, colWidths, table);\n  }\n\n  return tableMap;\n}\n\nfunction findWidth(table) {\n  var width = -1,\n      hasRowSpan = false;\n\n  for (var row = 0; row < table.childCount; row++) {\n    var rowNode = table.child(row),\n        rowWidth = 0;\n\n    if (hasRowSpan) {\n      for (var j = 0; j < row; j++) {\n        var prevRow = table.child(j);\n\n        for (var i = 0; i < prevRow.childCount; i++) {\n          var cell = prevRow.child(i);\n\n          if (j + cell.attrs.rowspan > row) {\n            rowWidth += cell.attrs.colspan;\n          }\n        }\n      }\n    }\n\n    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {\n      var cell$1 = rowNode.child(i$1);\n      rowWidth += cell$1.attrs.colspan;\n\n      if (cell$1.attrs.rowspan > 1) {\n        hasRowSpan = true;\n      }\n    }\n\n    if (width == -1) {\n      width = rowWidth;\n    } else if (width != rowWidth) {\n      width = Math.max(width, rowWidth);\n    }\n  }\n\n  return width;\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) {\n    map.problems = [];\n  }\n\n  for (var i = 0, seen = {}; i < map.map.length; i++) {\n    var pos = map.map[i];\n\n    if (seen[pos]) {\n      continue;\n    }\n\n    seen[pos] = true;\n    var node = table.nodeAt(pos),\n        updated = null;\n\n    for (var j = 0; j < node.attrs.colspan; j++) {\n      var col = (i + j) % map.width,\n          colWidth = colWidths[col * 2];\n\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth)) {\n        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n      }\n    }\n\n    if (updated) {\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos: pos,\n        colwidth: updated\n      });\n    }\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) {\n    return attrs.colwidth.slice();\n  }\n\n  var result = [];\n\n  for (var i = 0; i < attrs.colspan; i++) {\n    result.push(0);\n  }\n\n  return result;\n} // Helper for creating a schema that supports tables.\n\n\nfunction getCellAttrs(dom, extraAttrs) {\n  var widthAttr = dom.getAttribute(\"data-colwidth\");\n  var widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(function (s) {\n    return Number(s);\n  }) : null;\n  var colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  var result = {\n    colspan: colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n\n  for (var prop in extraAttrs) {\n    var getter = extraAttrs[prop].getFromDOM;\n    var value = getter && getter(dom);\n\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n\n  return result;\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  var attrs = {};\n\n  if (node.attrs.colspan != 1) {\n    attrs.colspan = node.attrs.colspan;\n  }\n\n  if (node.attrs.rowspan != 1) {\n    attrs.rowspan = node.attrs.rowspan;\n  }\n\n  if (node.attrs.colwidth) {\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  }\n\n  for (var prop in extraAttrs) {\n    var setter = extraAttrs[prop].setDOMAttr;\n\n    if (setter) {\n      setter(node.attrs[prop], attrs);\n    }\n  }\n\n  return attrs;\n} // :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\n\n\nfunction tableNodes(options) {\n  var extraAttrs = options.cellAttributes || {};\n  var cellAttrs = {\n    colspan: {\n      default: 1\n    },\n    rowspan: {\n      default: 1\n    },\n    colwidth: {\n      default: null\n    }\n  };\n\n  for (var prop in extraAttrs) {\n    cellAttrs[prop] = {\n      default: extraAttrs[prop].default\n    };\n  }\n\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{\n        tag: \"table\"\n      }],\n      toDOM: function toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{\n        tag: \"tr\"\n      }],\n      toDOM: function toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"td\",\n        getAttrs: function (dom) {\n          return getCellAttrs(dom, extraAttrs);\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"th\",\n        getAttrs: function (dom) {\n          return getCellAttrs(dom, extraAttrs);\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\n\nfunction tableNodeTypes(schema) {\n  var result = schema.cached.tableNodeTypes;\n\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n\n    for (var name in schema.nodes) {\n      var type = schema.nodes[name],\n          role = type.spec.tableRole;\n\n      if (role) {\n        result[role] = type;\n      }\n    }\n  }\n\n  return result;\n} // Various helper function for working with tables\n\n\nvar key = new PluginKey(\"selectingCells\");\n\nfunction cellAround($pos) {\n  for (var d = $pos.depth - 1; d > 0; d--) {\n    if ($pos.node(d).type.spec.tableRole == \"row\") {\n      return $pos.node(0).resolve($pos.before(d + 1));\n    }\n  }\n\n  return null;\n}\n\nfunction cellWrapping($pos) {\n  for (var d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    var role = $pos.node(d).type.spec.tableRole;\n\n    if (role === \"cell\" || role === 'header_cell') {\n      return $pos.node(d);\n    }\n  }\n\n  return null;\n}\n\nfunction isInTable(state) {\n  var $head = state.selection.$head;\n\n  for (var d = $head.depth; d > 0; d--) {\n    if ($head.node(d).type.spec.tableRole == \"row\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction selectionCell(state) {\n  var sel = state.selection;\n\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n\n  return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos) {\n  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    var role = after.type.spec.tableRole;\n\n    if (role == \"cell\" || role == \"header_cell\") {\n      return $pos.doc.resolve(pos);\n    }\n  }\n\n  for (var before = $pos.nodeBefore, pos$1 = $pos.pos; before; before = before.lastChild, pos$1--) {\n    var role$1 = before.type.spec.tableRole;\n\n    if (role$1 == \"cell\" || role$1 == \"header_cell\") {\n      return $pos.doc.resolve(pos$1 - before.nodeSize);\n    }\n  }\n}\n\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && $pos.nodeAfter;\n}\n\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\n\nfunction inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\n\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n\nfunction nextCell($pos, axis, dir) {\n  var start = $pos.start(-1),\n      map = TableMap.get($pos.node(-1));\n  var moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\n\nfunction setAttr(attrs, name, value) {\n  var result = {};\n\n  for (var prop in attrs) {\n    result[prop] = attrs[prop];\n  }\n\n  result[name] = value;\n  return result;\n}\n\nfunction removeColSpan(attrs, pos, n) {\n  if (n === void 0) n = 1;\n  var result = setAttr(attrs, \"colspan\", attrs.colspan - n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n\n    if (!result.colwidth.some(function (w) {\n      return w > 0;\n    })) {\n      result.colwidth = null;\n    }\n  }\n\n  return result;\n}\n\nfunction addColSpan(attrs, pos, n) {\n  if (n === void 0) n = 1;\n  var result = setAttr(attrs, \"colspan\", attrs.colspan + n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n\n    for (var i = 0; i < n; i++) {\n      result.colwidth.splice(pos, 0, 0);\n    }\n  }\n\n  return result;\n}\n\nfunction columnIsHeader(map, table, col) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (var row = 0; row < map.height; row++) {\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) {\n      return false;\n    }\n  }\n\n  return true;\n} // This file defines a ProseMirror selection subclass that models\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\n\n\nvar CellSelection = /*@__PURE__*/function (Selection) {\n  function CellSelection($anchorCell, $headCell) {\n    if ($headCell === void 0) $headCell = $anchorCell;\n    var table = $anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = $anchorCell.start(-1);\n    var rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    var cells = map.cellsInRect(rect).filter(function (p) {\n      return p != $headCell.pos - start;\n    }); // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n\n    cells.unshift($headCell.pos - start);\n    var ranges = cells.map(function (pos) {\n      var cell = table.nodeAt(pos),\n          from = pos + start + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    Selection.call(this, ranges[0].$from, ranges[0].$to, ranges); // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n\n    this.$anchorCell = $anchorCell; // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n\n    this.$headCell = $headCell;\n  }\n\n  if (Selection) CellSelection.__proto__ = Selection;\n  CellSelection.prototype = Object.create(Selection && Selection.prototype);\n  CellSelection.prototype.constructor = CellSelection;\n\n  CellSelection.prototype.map = function map(doc, mapping) {\n    var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    var $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n\n      if (tableChanged && this.isRowSelection()) {\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      } else if (tableChanged && this.isColSelection()) {\n        return CellSelection.colSelection($anchorCell, $headCell);\n      } else {\n        return new CellSelection($anchorCell, $headCell);\n      }\n    }\n\n    return TextSelection.between($anchorCell, $headCell);\n  }; // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n\n\n  CellSelection.prototype.content = function content() {\n    var table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    var rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n    var seen = {},\n        rows = [];\n\n    for (var row = rect.top; row < rect.bottom; row++) {\n      var rowContent = [];\n\n      for (var index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        var pos = map.map[index];\n\n        if (!seen[pos]) {\n          seen[pos] = true;\n          var cellRect = map.findCell(pos),\n              cell = table.nodeAt(pos);\n          var extraLeft = rect.left - cellRect.left,\n              extraRight = cellRect.right - rect.right;\n\n          if (extraLeft > 0 || extraRight > 0) {\n            var attrs = cell.attrs;\n\n            if (extraLeft > 0) {\n              attrs = removeColSpan(attrs, 0, extraLeft);\n            }\n\n            if (extraRight > 0) {\n              attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n            }\n\n            if (cellRect.left < rect.left) {\n              cell = cell.type.createAndFill(attrs);\n            } else {\n              cell = cell.type.create(attrs, cell.content);\n            }\n          }\n\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            var attrs$1 = setAttr(cell.attrs, \"rowspan\", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));\n\n            if (cellRect.top < rect.top) {\n              cell = cell.type.createAndFill(attrs$1);\n            } else {\n              cell = cell.type.create(attrs$1, cell.content);\n            }\n          }\n\n          rowContent.push(cell);\n        }\n      }\n\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  };\n\n  CellSelection.prototype.replace = function replace(tr, content) {\n    if (content === void 0) content = Slice.empty;\n    var mapFrom = tr.steps.length,\n        ranges = this.ranges;\n\n    for (var i = 0; i < ranges.length; i++) {\n      var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n\n    var sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n\n    if (sel) {\n      tr.setSelection(sel);\n    }\n  };\n\n  CellSelection.prototype.replaceWith = function replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  };\n\n  CellSelection.prototype.forEachCell = function forEachCell(f) {\n    var table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    var cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n\n    for (var i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), start + cells[i]);\n    }\n  }; // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n\n\n  CellSelection.prototype.isColSelection = function isColSelection() {\n    var anchorTop = this.$anchorCell.index(-1),\n        headTop = this.$headCell.index(-1);\n\n    if (Math.min(anchorTop, headTop) > 0) {\n      return false;\n    }\n\n    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n  }; // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n\n\n  CellSelection.colSelection = function colSelection($anchorCell, $headCell) {\n    if ($headCell === void 0) $headCell = $anchorCell;\n    var map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) {\n        $anchorCell = doc.resolve(start + map.map[anchorRect.left]);\n      }\n\n      if (headRect.bottom < map.height) {\n        $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n      }\n    } else {\n      if (headRect.top > 0) {\n        $headCell = doc.resolve(start + map.map[headRect.left]);\n      }\n\n      if (anchorRect.bottom < map.height) {\n        $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n      }\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  }; // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n\n\n  CellSelection.prototype.isRowSelection = function isRowSelection() {\n    var map = TableMap.get(this.$anchorCell.node(-1)),\n        start = this.$anchorCell.start(-1);\n    var anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start);\n\n    if (Math.min(anchorLeft, headLeft) > 0) {\n      return false;\n    }\n\n    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  };\n\n  CellSelection.prototype.eq = function eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }; // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n\n\n  CellSelection.rowSelection = function rowSelection($anchorCell, $headCell) {\n    if ($headCell === void 0) $headCell = $anchorCell;\n    var map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) {\n        $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);\n      }\n\n      if (headRect.right < map.width) {\n        $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]);\n      }\n    } else {\n      if (headRect.left > 0) {\n        $headCell = doc.resolve(start + map.map[headRect.top * map.width]);\n      }\n\n      if (anchorRect.right < map.width) {\n        $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]);\n      }\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  };\n\n  CellSelection.prototype.toJSON = function toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  };\n\n  CellSelection.fromJSON = function fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }; // :: (Node, number, ?number) → CellSelection\n\n\n  CellSelection.create = function create(doc, anchorCell, headCell) {\n    if (headCell === void 0) headCell = anchorCell;\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  };\n\n  CellSelection.prototype.getBookmark = function getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  };\n\n  return CellSelection;\n}(Selection);\n\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\n\nvar CellBookmark = function CellBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\n\nCellBookmark.prototype.map = function map(mapping) {\n  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n};\n\nCellBookmark.prototype.resolve = function resolve(doc) {\n  var $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n\n  if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) {\n    return new CellSelection($anchorCell, $headCell);\n  } else {\n    return Selection.near($headCell, 1);\n  }\n};\n\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) {\n    return null;\n  }\n\n  var cells = [];\n  state.selection.forEachCell(function (node, pos) {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: \"selectedCell\"\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) {\n    return false;\n  } // Cheap elimination\n\n\n  var afterFrom = $from.pos,\n      beforeTo = $to.pos,\n      depth = $from.depth;\n\n  for (; depth >= 0; depth--, afterFrom++) {\n    if ($from.after(depth + 1) < $from.end(depth)) {\n      break;\n    }\n  }\n\n  for (var d = $to.depth; d >= 0; d--, beforeTo--) {\n    if ($to.before(d + 1) > $to.start(d)) {\n      break;\n    }\n  }\n\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\n\nfunction isTextSelectionAcrossCells(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var fromCellBoundaryNode;\n  var toCellBoundaryNode;\n\n  for (var i = $from.depth; i > 0; i--) {\n    var node = $from.node(i);\n\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (var i$1 = $to.depth; i$1 > 0; i$1--) {\n    var node$1 = $to.node(i$1);\n\n    if (node$1.type.spec.tableRole === 'cell' || node$1.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node$1;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  var sel = (tr || state).selection,\n      doc = (tr || state).doc,\n      normalize,\n      role;\n\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      var $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      var map = TableMap.get(sel.node),\n          start = sel.from + 1;\n      var lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n\n  if (normalize) {\n    (tr || (tr = state.tr)).setSelection(normalize);\n  }\n\n  return tr;\n} // Utilities used for copy/paste handling.\n// Utilities to help with copying and pasting table cells\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\n\n\nfunction pastedCells(slice) {\n  if (!slice.size) {\n    return null;\n  }\n\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n\n  var first = content.firstChild,\n      role = first.type.spec.tableRole;\n  var schema = first.type.schema,\n      rows = [];\n\n  if (role == \"row\") {\n    for (var i = 0; i < content.childCount; i++) {\n      var cells = content.child(i).content;\n      var left = i ? 0 : Math.max(0, openStart - 1);\n      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n\n      if (left || right) {\n        cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;\n      }\n\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n\n  return ensureRectangular(schema, rows);\n} // : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\n\n\nfunction ensureRectangular(schema, rows) {\n  var widths = [];\n\n  for (var i = 0; i < rows.length; i++) {\n    var row = rows[i];\n\n    for (var j = row.childCount - 1; j >= 0; j--) {\n      var ref = row.child(j).attrs;\n      var rowspan = ref.rowspan;\n      var colspan = ref.colspan;\n\n      for (var r = i; r < i + rowspan; r++) {\n        widths[r] = (widths[r] || 0) + colspan;\n      }\n    }\n  }\n\n  var width = 0;\n\n  for (var r$1 = 0; r$1 < widths.length; r$1++) {\n    width = Math.max(width, widths[r$1]);\n  }\n\n  for (var r$2 = 0; r$2 < widths.length; r$2++) {\n    if (r$2 >= rows.length) {\n      rows.push(Fragment.empty);\n    }\n\n    if (widths[r$2] < width) {\n      var empty = tableNodeTypes(schema).cell.createAndFill(),\n          cells = [];\n\n      for (var i$1 = widths[r$2]; i$1 < width; i$1++) {\n        cells.push(empty);\n      }\n\n      rows[r$2] = rows[r$2].append(Fragment.from(cells));\n    }\n  }\n\n  return {\n    height: rows.length,\n    width: width,\n    rows: rows\n  };\n}\n\nfunction fitSlice(nodeType, slice) {\n  var node = nodeType.createAndFill();\n  var tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n} // : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\n\n\nfunction clipCells(ref, newWidth, newHeight) {\n  var width = ref.width;\n  var height = ref.height;\n  var rows = ref.rows;\n\n  if (width != newWidth) {\n    var added = [],\n        newRows = [];\n\n    for (var row = 0; row < rows.length; row++) {\n      var frag = rows[row],\n          cells = [];\n\n      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {\n        var cell = frag.child(i % frag.childCount);\n\n        if (col + cell.attrs.colspan > newWidth) {\n          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        }\n\n        cells.push(cell);\n        col += cell.attrs.colspan;\n\n        for (var j = 1; j < cell.attrs.rowspan; j++) {\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n        }\n      }\n\n      newRows.push(Fragment.from(cells));\n    }\n\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    var newRows$1 = [];\n\n    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {\n      var cells$1 = [],\n          source = rows[i$1 % height];\n\n      for (var j$1 = 0; j$1 < source.childCount; j$1++) {\n        var cell$1 = source.child(j$1);\n\n        if (row$1 + cell$1.attrs.rowspan > newHeight) {\n          cell$1 = cell$1.type.create(setAttr(cell$1.attrs, \"rowspan\", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content);\n        }\n\n        cells$1.push(cell$1);\n      }\n\n      newRows$1.push(Fragment.from(cells$1));\n    }\n\n    rows = newRows$1;\n    height = newHeight;\n  }\n\n  return {\n    width: width,\n    height: height,\n    rows: rows\n  };\n} // Make sure a table has at least the given width and height. Return\n// true if something was changed.\n\n\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  var schema = tr.doc.type.schema,\n      types = tableNodeTypes(schema),\n      empty,\n      emptyHead;\n\n  if (width > map.width) {\n    for (var row = 0, rowEnd = 0; row < map.height; row++) {\n      var rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      var cells = [],\n          add = void 0;\n\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) {\n        add = empty || (empty = types.cell.createAndFill());\n      } else {\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      }\n\n      for (var i = map.width; i < width; i++) {\n        cells.push(add);\n      }\n\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n\n  if (height > map.height) {\n    var cells$1 = [];\n\n    for (var i$1 = 0, start$1 = (map.height - 1) * map.width; i$1 < Math.max(map.width, width); i$1++) {\n      var header = i$1 >= map.width ? false : table.nodeAt(map.map[start$1 + i$1]).type == types.header_cell;\n      cells$1.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n\n    var emptyRow = types.row.create(null, Fragment.from(cells$1)),\n        rows = [];\n\n    for (var i$2 = map.height; i$2 < height; i$2++) {\n      rows.push(emptyRow);\n    }\n\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n\n  return !!(empty || emptyHead);\n} // Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\n\n\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) {\n    return false;\n  }\n\n  var found = false;\n\n  for (var col = left; col < right; col++) {\n    var index = top * map.width + col,\n        pos = map.map[index];\n\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos);\n      var ref = map.findCell(pos);\n      var cellTop = ref.top;\n      var cellLeft = ref.left;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, \"rowspan\", top - cellTop));\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill(setAttr(cell.attrs, \"rowspan\", cellTop + cell.attrs.rowspan - top)));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n\n  return found;\n} // Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\n\n\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) {\n    return false;\n  }\n\n  var found = false;\n\n  for (var row = top; row < bottom; row++) {\n    var index = row * map.width + left,\n        pos = map.map[index];\n\n    if (map.map[index - 1] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos),\n          cellLeft = map.colCount(pos);\n      var updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n\n  return found;\n} // Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\n\n\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc,\n      map = TableMap.get(table);\n  var top = rect.top;\n  var left = rect.left;\n  var right = left + cells.width,\n      bottom = top + cells.height;\n  var tr = state.tr,\n      mapFrom = 0;\n\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  } // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n\n\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) {\n    recomp();\n  }\n\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) {\n    recomp();\n  }\n\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) {\n    recomp();\n  }\n\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) {\n    recomp();\n  }\n\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) {\n    recomp();\n  }\n\n  for (var row = top; row < bottom; row++) {\n    var from = map.positionAt(row, left, table),\n        to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top], 0, 0));\n  }\n\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n} // This file defines a number of helpers for wiring up user input to\n\n\nvar handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  \"Backspace\": deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  \"Delete\": deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction arrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));\n    }\n\n    if (axis != \"horiz\" && !sel.empty) {\n      return false;\n    }\n\n    var end = atEndOfCell(view, axis, dir);\n\n    if (end == null) {\n      return false;\n    }\n\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      var $cell = state.doc.resolve(end),\n          $next = nextCell($cell, axis, dir),\n          newSel;\n\n      if ($next) {\n        newSel = Selection.near($next, 1);\n      } else if (dir < 0) {\n        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      } else {\n        newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      }\n\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n\n    if (!(sel instanceof CellSelection)) {\n      var end = atEndOfCell(view, axis, dir);\n\n      if (end == null) {\n        return false;\n      }\n\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n\n    var $head = nextCell(sel.$headCell, axis, dir);\n\n    if (!$head) {\n      return false;\n    }\n\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head));\n  };\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  var sel = state.selection;\n\n  if (!(sel instanceof CellSelection)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var tr = state.tr,\n        baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell(function (cell, pos) {\n      if (!cell.content.eq(baseContent)) {\n        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));\n      }\n    });\n\n    if (tr.docChanged) {\n      dispatch(tr);\n    }\n  }\n\n  return true;\n}\n\nfunction handleTripleClick(view, pos) {\n  var doc = view.state.doc,\n      $cell = cellAround(doc.resolve(pos));\n\n  if (!$cell) {\n    return false;\n  }\n\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\n\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) {\n    return false;\n  }\n\n  var cells = pastedCells(slice),\n      sel = view.state.selection;\n\n  if (sel instanceof CellSelection) {\n    if (!cells) {\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n      };\n    }\n\n    var table = sel.$anchorCell.node(-1),\n        start = sel.$anchorCell.start(-1);\n    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    var $cell = selectionCell(view.state),\n        start$1 = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) {\n    return;\n  }\n\n  var startDOMCell = domInCell(view, startEvent.target),\n      $anchor;\n\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  } // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n\n\n  function setCellSelection($anchor, event) {\n    var $head = cellUnderMouse(view, event);\n    var starting = key.getState(view.state) == null;\n\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) {\n        $head = $anchor;\n      } else {\n        return;\n      }\n    }\n\n    var selection = new CellSelection($anchor, $head);\n\n    if (starting || !view.state.selection.eq(selection)) {\n      var tr = view.state.tr.setSelection(selection);\n\n      if (starting) {\n        tr.setMeta(key, $anchor.pos);\n      }\n\n      view.dispatch(tr);\n    }\n  } // Stop listening to mouse motion events.\n\n\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n\n    if (key.getState(view.state) != null) {\n      view.dispatch(view.state.tr.setMeta(key, -1));\n    }\n  }\n\n  function move(event) {\n    var anchor = key.getState(view.state),\n        $anchor;\n\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n\n      if (!$anchor) {\n        return stop();\n      }\n    }\n\n    if ($anchor) {\n      setCellSelection($anchor, event);\n    }\n  }\n\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n} // Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\n\n\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) {\n    return null;\n  }\n\n  var ref = view.state.selection;\n  var $head = ref.$head;\n\n  for (var d = $head.depth - 1; d >= 0; d--) {\n    var parent = $head.node(d),\n        index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n\n    if (index != (dir < 0 ? 0 : parent.childCount)) {\n      return null;\n    }\n\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      var cellPos = $head.before(d);\n      var dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n\n  return null;\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n}\n\nfunction cellUnderMouse(view, event) {\n  var mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n\n  if (!mousePos) {\n    return null;\n  }\n\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n} // This file defines helpers for normalizing tables, making sure no\n\n\nvar fixTablesKey = new PluginKey(\"fix-tables\"); // Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\n\nfunction changedDescendants(old, cur, offset, f) {\n  var oldSize = old.childCount,\n      curSize = cur.childCount;\n\n  outer: for (var i = 0, j = 0; i < curSize; i++) {\n    var child = cur.child(i);\n\n    for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n\n    f(child, offset);\n\n    if (j < oldSize && old.child(j).sameMarkup(child)) {\n      changedDescendants(old.child(j), child, offset + 1, f);\n    } else {\n      child.nodesBetween(0, child.content.size, f, offset + 1);\n    }\n\n    offset += child.nodeSize;\n  }\n} // :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\n\n\nfunction fixTables(state, oldState) {\n  var tr,\n      check = function (node, pos) {\n    if (node.type.spec.tableRole == \"table\") {\n      tr = fixTable(state, node, pos, tr);\n    }\n  };\n\n  if (!oldState) {\n    state.doc.descendants(check);\n  } else if (oldState.doc != state.doc) {\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  }\n\n  return tr;\n} // : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\n\n\nfunction fixTable(state, table, tablePos, tr) {\n  var map = TableMap.get(table);\n\n  if (!map.problems) {\n    return tr;\n  }\n\n  if (!tr) {\n    tr = state.tr;\n  } // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n\n\n  var mustAdd = [];\n\n  for (var i = 0; i < map.height; i++) {\n    mustAdd.push(0);\n  }\n\n  for (var i$1 = 0; i$1 < map.problems.length; i$1++) {\n    var prob = map.problems[i$1];\n\n    if (prob.type == \"collision\") {\n      var cell = table.nodeAt(prob.pos);\n\n      for (var j = 0; j < cell.attrs.rowspan; j++) {\n        mustAdd[prob.row + j] += prob.n;\n      }\n\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      var cell$1 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, \"rowspan\", cell$1.attrs.rowspan - prob.n));\n    } else if (prob.type == \"colwidth mismatch\") {\n      var cell$2 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, \"colwidth\", prob.colwidth));\n    }\n  }\n\n  var first, last;\n\n  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) {\n    if (mustAdd[i$2]) {\n      if (first == null) {\n        first = i$2;\n      }\n\n      last = i$2;\n    }\n  } // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n\n\n  for (var i$3 = 0, pos = tablePos + 1; i$3 < map.height; i$3++) {\n    var row = table.child(i$3);\n    var end = pos + row.nodeSize;\n    var add = mustAdd[i$3];\n\n    if (add > 0) {\n      var tableNodeType = 'cell';\n\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n\n      var nodes = [];\n\n      for (var j$1 = 0; j$1 < add; j$1++) {\n        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n      }\n\n      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n\n    pos = end;\n  }\n\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n} // This file defines a number of table-related commands.\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\n\n\nfunction selectedRect(state) {\n  var sel = state.selection,\n      $pos = selectionCell(state);\n  var table = $pos.node(-1),\n      tableStart = $pos.start(-1),\n      map = TableMap.get(table);\n  var rect;\n\n  if (sel instanceof CellSelection) {\n    rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);\n  } else {\n    rect = map.findCell($pos.pos - tableStart);\n  }\n\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect;\n} // Add a column at the given position in a table.\n\n\nfunction addColumn(tr, ref, col) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n  var refColumn = col > 0 ? -1 : 0;\n\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n\n  for (var row = 0; row < map.height; row++) {\n    var index = row * map.width + col; // If this position falls inside a col-spanning cell\n\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      var pos = map.map[index],\n          cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos))); // Skip ahead if rowspan > 1\n\n      row += cell.attrs.rowspan - 1;\n    } else {\n      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      var pos$1 = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());\n    }\n  }\n\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\n\n\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\n\n\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n\n  return true;\n}\n\nfunction removeColumn(tr, ref, col) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n  var mapStart = tr.mapping.maps.length;\n\n  for (var row = 0; row < map.height;) {\n    var index = row * map.width + col,\n        pos = map.map[index],\n        cell = table.nodeAt(pos); // If this is part of a col-spanning cell\n\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map.colCount(pos)));\n    } else {\n      var start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n\n    row += cell.attrs.rowspan;\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\n\n\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state),\n        tr = state.tr;\n\n    if (rect.left == 0 && rect.right == rect.map.width) {\n      return false;\n    }\n\n    for (var i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n\n      if (i == rect.left) {\n        break;\n      }\n\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction rowIsHeader(map, table, row) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (var col = 0; col < map.width; col++) {\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction addRow(tr, ref, row) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n  var rowPos = tableStart;\n\n  for (var i = 0; i < row; i++) {\n    rowPos += table.child(i).nodeSize;\n  }\n\n  var cells = [],\n      refRow = row > 0 ? -1 : 0;\n\n  if (rowIsHeader(map, table, row + refRow)) {\n    refRow = row == 0 || row == map.height ? null : 0;\n  }\n\n  for (var col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      var pos = map.map[index],\n          attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, \"rowspan\", attrs.rowspan + 1));\n      col += attrs.colspan - 1;\n    } else {\n      var type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\n\n\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\n\n\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n\n  return true;\n}\n\nfunction removeRow(tr, ref, row) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n  var rowPos = 0;\n\n  for (var i = 0; i < row; i++) {\n    rowPos += table.child(i).nodeSize;\n  }\n\n  var nextRow = rowPos + table.child(row).nodeSize;\n  var mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (var col = 0, index = row * map.width; col < map.width; col++, index++) {\n    var pos = map.map[index];\n\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      var attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, \"rowspan\", attrs.rowspan - 1));\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      var cell = table.nodeAt(pos);\n      var copy = cell.type.create(setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - 1), cell.content);\n      var newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\n\n\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var rect = selectedRect(state),\n        tr = state.tr;\n\n    if (rect.top == 0 && rect.bottom == rect.map.height) {\n      return false;\n    }\n\n    for (var i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n\n      if (i == rect.top) {\n        break;\n      }\n\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction isEmpty(cell) {\n  var c = cell.content;\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;\n}\n\nfunction cellsOverlapRectangle(ref, rect) {\n  var width = ref.width;\n  var height = ref.height;\n  var map = ref.map;\n  var indexTop = rect.top * width + rect.left,\n      indexLeft = indexTop;\n  var indexBottom = (rect.bottom - 1) * width + rect.left,\n      indexRight = indexTop + (rect.right - rect.left - 1);\n\n  for (var i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) {\n      return true;\n    }\n\n    indexLeft += width;\n    indexRight += width;\n  }\n\n  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) {\n      return true;\n    }\n\n    indexTop++;\n    indexBottom++;\n  }\n\n  return false;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\n\n\nfunction mergeCells(state, dispatch) {\n  var sel = state.selection;\n\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) {\n    return false;\n  }\n\n  var rect = selectedRect(state);\n  var map = rect.map;\n\n  if (cellsOverlapRectangle(map, rect)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var tr = state.tr,\n        seen = {},\n        content = Fragment.empty,\n        mergedPos,\n        mergedCell;\n\n    for (var row = rect.top; row < rect.bottom; row++) {\n      for (var col = rect.left; col < rect.right; col++) {\n        var cellPos = map.map[row * map.width + col],\n            cell = rect.table.nodeAt(cellPos);\n\n        if (seen[cellPos]) {\n          continue;\n        }\n\n        seen[cellPos] = true;\n\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) {\n            content = content.append(cell.content);\n          }\n\n          var mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), \"rowspan\", rect.bottom - rect.top));\n\n    if (content.size) {\n      var end = mergedPos + 1 + mergedCell.content.size;\n      var start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\n\n\nfunction splitCell(state, dispatch) {\n  var nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(function (ref) {\n    var node = ref.node;\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n} // :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\n\n\nfunction splitCellWithType(getCellType) {\n  return function (state, dispatch) {\n    var sel = state.selection;\n    var cellNode, cellPos;\n\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n\n      if (!cellNode) {\n        return false;\n      }\n\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) {\n        return false;\n      }\n\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n\n    if (dispatch) {\n      var baseAttrs = cellNode.attrs,\n          attrs = [],\n          colwidth = baseAttrs.colwidth;\n\n      if (baseAttrs.rowspan > 1) {\n        baseAttrs = setAttr(baseAttrs, \"rowspan\", 1);\n      }\n\n      if (baseAttrs.colspan > 1) {\n        baseAttrs = setAttr(baseAttrs, \"colspan\", 1);\n      }\n\n      var rect = selectedRect(state),\n          tr = state.tr;\n\n      for (var i = 0; i < rect.right - rect.left; i++) {\n        attrs.push(colwidth ? setAttr(baseAttrs, \"colwidth\", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);\n      }\n\n      var lastCell;\n\n      for (var row = rect.top; row < rect.bottom; row++) {\n        var pos = rect.map.positionAt(row, rect.left, rect.table);\n\n        if (row == rect.top) {\n          pos += cellNode.nodeSize;\n        }\n\n        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {\n          if (col == rect.left && row == rect.top) {\n            continue;\n          }\n\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row: row,\n            col: col\n          }).createAndFill(attrs[i$1]));\n        }\n      }\n\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n\n      if (sel instanceof CellSelection) {\n        tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));\n      }\n\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\n\n\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) {\n      return false;\n    }\n\n    var $cell = selectionCell(state);\n\n    if ($cell.nodeAfter.attrs[name] === value) {\n      return false;\n    }\n\n    if (dispatch) {\n      var tr = state.tr;\n\n      if (state.selection instanceof CellSelection) {\n        state.selection.forEachCell(function (node, pos) {\n          if (node.attrs[name] !== value) {\n            tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n          }\n        });\n      } else {\n        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));\n      }\n\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) {\n      return false;\n    }\n\n    if (dispatch) {\n      var types = tableNodeTypes(state.schema);\n      var rect = selectedRect(state),\n          tr = state.tr;\n      var cells = rect.map.cellsInRect(type == \"column\" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == \"row\" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);\n      var nodes = cells.map(function (pos) {\n        return rect.table.nodeAt(pos);\n      });\n\n      for (var i = 0; i < cells.length; i++) // Remove headers, if any\n      {\n        if (nodes[i].type == types.header_cell) {\n          tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n        }\n      }\n\n      if (tr.steps.length == 0) {\n        for (var i$1 = 0; i$1 < cells.length; i$1++) // No headers removed, add instead\n        {\n          tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs);\n        }\n      }\n\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  var cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n\n  for (var i = 0; i < cellPositions.length; i++) {\n    var cell = rect.table.nodeAt(cellPositions[i]);\n\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n} // :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\n\n\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n\n  if (options.useDeprecatedLogic) {\n    return deprecated_toggleHeader(type);\n  }\n\n  return function (state, dispatch) {\n    if (!isInTable(state)) {\n      return false;\n    }\n\n    if (dispatch) {\n      var types = tableNodeTypes(state.schema);\n      var rect = selectedRect(state),\n          tr = state.tr;\n      var isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      var isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n      var isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      var selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      var cellsRect = type == \"column\" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == \"row\" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;\n      var newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(function (relativeCellPos) {\n        var cellPos = relativeCellPos + rect.tableStart;\n        var cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\n\n\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\n\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\n\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    var before = $cell.nodeBefore;\n\n    if (before) {\n      return $cell.pos - before.nodeSize;\n    }\n\n    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      var rowNode = $cell.node(-1).child(row);\n\n      if (rowNode.childCount) {\n        return rowEnd - 1 - rowNode.lastChild.nodeSize;\n      }\n\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n\n    var table = $cell.node(-1);\n\n    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {\n      var rowNode$1 = table.child(row$1);\n\n      if (rowNode$1.childCount) {\n        return rowStart + 1;\n      }\n\n      rowStart += rowNode$1.nodeSize;\n    }\n  }\n} // :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\n\n\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) {\n      return false;\n    }\n\n    var cell = findNextCell(selectionCell(state), direction);\n\n    if (cell == null) {\n      return;\n    }\n\n    if (dispatch) {\n      var $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\n\n\nfunction deleteTable(state, dispatch) {\n  var $pos = state.selection.$anchor;\n\n  for (var d = $pos.depth; d > 0; d--) {\n    var node = $pos.node(d);\n\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) {\n        dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TableView = function TableView(node, cellMinWidth) {\n  this.node = node;\n  this.cellMinWidth = cellMinWidth;\n  this.dom = document.createElement(\"div\");\n  this.dom.className = \"tableWrapper\";\n  this.table = this.dom.appendChild(document.createElement(\"table\"));\n  this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n  updateColumns(node, this.colgroup, this.table, cellMinWidth);\n  this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n};\n\nTableView.prototype.update = function update(node) {\n  if (node.type != this.node.type) {\n    return false;\n  }\n\n  this.node = node;\n  updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n  return true;\n};\n\nTableView.prototype.ignoreMutation = function ignoreMutation(record) {\n  return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n};\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var totalWidth = 0,\n      fixedWidth = true;\n  var nextDOM = colgroup.firstChild,\n      row = node.firstChild;\n\n  for (var i = 0, col = 0; i < row.childCount; i++) {\n    var ref = row.child(i).attrs;\n    var colspan = ref.colspan;\n    var colwidth = ref.colwidth;\n\n    for (var j = 0; j < colspan; j++, col++) {\n      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      var cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n\n      if (!hasWidth) {\n        fixedWidth = false;\n      }\n\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    var after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\nvar key$1 = new PluginKey(\"tableColumnResizing\");\n\nfunction columnResizing(ref) {\n  if (ref === void 0) ref = {};\n  var handleWidth = ref.handleWidth;\n  if (handleWidth === void 0) handleWidth = 5;\n  var cellMinWidth = ref.cellMinWidth;\n  if (cellMinWidth === void 0) cellMinWidth = 25;\n  var View = ref.View;\n  if (View === void 0) View = TableView;\n  var lastColumnResizable = ref.lastColumnResizable;\n  if (lastColumnResizable === void 0) lastColumnResizable = true;\n  var plugin = new Plugin({\n    key: key$1,\n    state: {\n      init: function init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function (node, view) {\n          return new View(node, cellMinWidth, view);\n        };\n\n        return new ResizeState(-1, false);\n      },\n      apply: function apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: function attributes(state) {\n        var pluginState = key$1.getState(state);\n        return pluginState.activeHandle > -1 ? {\n          class: \"resize-cursor\"\n        } : null;\n      },\n      handleDOMEvents: {\n        mousemove: function mousemove(view, event) {\n          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n        },\n        mouseleave: function mouseleave(view) {\n          handleMouseLeave(view);\n        },\n        mousedown: function mousedown(view, event) {\n          handleMouseDown$1(view, event, cellMinWidth);\n        }\n      },\n      decorations: function decorations(state) {\n        var pluginState = key$1.getState(state);\n\n        if (pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\n\nvar ResizeState = function ResizeState(activeHandle, dragging) {\n  this.activeHandle = activeHandle;\n  this.dragging = dragging;\n};\n\nResizeState.prototype.apply = function apply(tr) {\n  var state = this,\n      action = tr.getMeta(key$1);\n\n  if (action && action.setHandle != null) {\n    return new ResizeState(action.setHandle, null);\n  }\n\n  if (action && action.setDragging !== undefined) {\n    return new ResizeState(state.activeHandle, action.setDragging);\n  }\n\n  if (state.activeHandle > -1 && tr.docChanged) {\n    var handle = tr.mapping.map(state.activeHandle, -1);\n\n    if (!pointsAtCell(tr.doc.resolve(handle))) {\n      handle = null;\n    }\n\n    state = new ResizeState(handle, state.dragging);\n  }\n\n  return state;\n};\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  var pluginState = key$1.getState(view.state);\n\n  if (!pluginState.dragging) {\n    var target = domCellAround(event.target),\n        cell = -1;\n\n    if (target) {\n      var ref = target.getBoundingClientRect();\n      var left = ref.left;\n      var right = ref.right;\n\n      if (event.clientX - left <= handleWidth) {\n        cell = edgeCell(view, event, \"left\");\n      } else if (right - event.clientX <= handleWidth) {\n        cell = edgeCell(view, event, \"right\");\n      }\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        var $cell = view.state.doc.resolve(cell);\n        var table = $cell.node(-1),\n            map = TableMap.get(table),\n            start = $cell.start(-1);\n        var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  var pluginState = key$1.getState(view.state);\n\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) {\n    updateHandle(view, -1);\n  }\n}\n\nfunction handleMouseDown$1(view, event, cellMinWidth) {\n  var pluginState = key$1.getState(view.state);\n\n  if (pluginState.activeHandle == -1 || pluginState.dragging) {\n    return false;\n  }\n\n  var cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(key$1, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n\n  function finish(event) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    var pluginState = key$1.getState(view.state);\n\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(key$1, {\n        setDragging: null\n      }));\n    }\n  }\n\n  function move(event) {\n    if (!event.which) {\n      return finish(event);\n    }\n\n    var pluginState = key$1.getState(view.state);\n    var dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(view, cellPos, ref) {\n  var colspan = ref.colspan;\n  var colwidth = ref.colwidth;\n  var width = colwidth && colwidth[colwidth.length - 1];\n\n  if (width) {\n    return width;\n  }\n\n  var dom = view.domAtPos(cellPos);\n  var node = dom.node.childNodes[dom.offset];\n  var domWidth = node.offsetWidth,\n      parts = colspan;\n\n  if (colwidth) {\n    for (var i = 0; i < colspan; i++) {\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n    }\n  }\n\n  return domWidth / parts;\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\") {\n    target = target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  }\n\n  return target;\n}\n\nfunction edgeCell(view, event, side) {\n  var found = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n\n  if (!found) {\n    return -1;\n  }\n\n  var pos = found.pos;\n  var $cell = cellAround(view.state.doc.resolve(pos));\n\n  if (!$cell) {\n    return -1;\n  }\n\n  if (side == \"right\") {\n    return $cell.pos;\n  }\n\n  var map = TableMap.get($cell.node(-1)),\n      start = $cell.start(-1);\n  var index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  var offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key$1, {\n    setHandle: value\n  }));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var tr = view.state.tr;\n\n  for (var row = 0; row < map.height; row++) {\n    var mapIndex = row * map.width + col; // Rowspanning cell that has already been handled\n\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) {\n      continue;\n    }\n\n    var pos = map.map[mapIndex];\n    var ref = table.nodeAt(pos);\n    var attrs = ref.attrs;\n    var index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n\n    if (attrs.colwidth && attrs.colwidth[index] == width) {\n      continue;\n    }\n\n    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, \"colwidth\", colwidth));\n  }\n\n  if (tr.docChanged) {\n    view.dispatch(tr);\n  }\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1),\n      start = $cell.start(-1);\n  var col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var dom = view.domAtPos($cell.start(-1)).node;\n\n  while (dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  var result = [];\n\n  for (var i = 0; i < n; i++) {\n    result.push(0);\n  }\n\n  return result;\n}\n\nfunction handleDecorations(state, cell) {\n  var decorations = [];\n  var $cell = state.doc.resolve(cell);\n  var table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n\n  for (var row = 0; row < map.height; row++) {\n    var index = col + row * map.width - 1; // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      var cellPos = map.map[index];\n      var pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      var dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n\n  return DecorationSet.create(state.doc, decorations);\n} // This file defines a plugin that handles the drawing of cell\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\n\n\nfunction tableEditing(ref) {\n  if (ref === void 0) ref = {};\n  var allowTableNodeSelection = ref.allowTableNodeSelection;\n  if (allowTableNodeSelection === void 0) allowTableNodeSelection = false;\n  return new Plugin({\n    key: key,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init: function init() {\n        return null;\n      },\n      apply: function apply(tr, cur) {\n        var set = tr.getMeta(key);\n\n        if (set != null) {\n          return set == -1 ? null : set;\n        }\n\n        if (cur == null || !tr.docChanged) {\n          return cur;\n        }\n\n        var ref = tr.mapping.mapResult(cur);\n        var deleted = ref.deleted;\n        var pos = ref.pos;\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween: function createSelectionBetween(view) {\n        if (key.getState(view.state) != null) {\n          return view.state.selection;\n        }\n      },\n      handleTripleClick: handleTripleClick,\n      handleKeyDown: handleKeyDown,\n      handlePaste: handlePaste\n    },\n    appendTransaction: function appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n  });\n}\n\nexport { CellSelection, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, colCount, columnIsHeader, columnResizing, key$1 as columnResizingPluginKey, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setAttr, setCellAttr, splitCell, splitCellWithType, tableEditing, key as tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumns as updateColumnsOnResize };","map":{"version":3,"sources":["../src/tablemap.js","../src/schema.js","../src/util.js","../src/cellselection.js","../src/copypaste.js","../src/input.js","../src/fixtables.js","../src/commands.js","../src/tableview.js","../src/columnresizing.js","../src/index.js"],"names":["let","cache","j","i","cell","const","pos","role","super","attrs","node","r","newRows","row","cells","start","rowNode","key","handleMouseDown","tableEditingKey"],"mappings":"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","sourcesContent":["// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nlet readFromCache, addToCache\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != \"undefined\") {\n  let cache = new WeakMap\n  readFromCache = key => cache.get(key)\n  addToCache = (key, value) => {\n    cache.set(key, value)\n    return value\n  }\n} else {\n  let cache = [], cacheSize = 10, cachePos = 0\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1]\n  }\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0\n    cache[cachePos++] = key\n    return cache[cachePos++] = value\n  }\n}\n\nexport class Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left; this.top = top; this.right = right; this.bottom = bottom\n  }\n}\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nexport class TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width\n    // :: number The table's height\n    this.height = height\n    // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n    this.map = map\n    // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n    this.problems = problems\n  }\n\n  // :: (number) → Rect\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i]\n      if (curPos != pos) continue\n      let left = i % this.width, top = (i / this.width) | 0\n      let right = left + 1, bottom = top + 1\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++\n      for (let j = 1; bottom < this.height && this.map[i + (this.width * j)] == curPos; j++) bottom++\n      return new Rect(left, top, right, bottom)\n    }\n    throw new RangeError(\"No cell with offset \" + pos + \" found\")\n  }\n\n  // :: (number) → number\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++)\n      if (this.map[i] == pos) return i % this.width\n    throw new RangeError(\"No cell with offset \" + pos + \" found\")\n  }\n\n  // :: (number, string, number) → ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    let {left, right, top, bottom} = this.findCell(pos)\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)]\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)]\n    }\n  }\n\n  // :: (number, number) → Rect\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    let {left: leftA, right: rightA, top: topA, bottom: bottomA} = this.findCell(a)\n    let {left: leftB, right: rightB, top: topB, bottom: bottomB} = this.findCell(b)\n    return new Rect(Math.min(leftA, leftB), Math.min(topA, topB),\n                    Math.max(rightA, rightB), Math.max(bottomA, bottomB))\n  }\n\n  // :: (Rect) → [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    let result = [], seen = {}\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col, pos = this.map[index]\n        if (seen[pos]) continue\n        seen[pos] = true\n        if ((col != rect.left || !col || this.map[index - 1] != pos) &&\n            (row != rect.top || !row || this.map[index - this.width] != pos))\n          result.push(pos)\n      }\n    }\n    return result\n  }\n\n  // :: (number, number, Node) → number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize\n      if (i == row) {\n        let index = col + row * this.width, rowEndIndex = (row + 1) * this.width\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index]\n      }\n      rowStart = rowEnd\n    }\n  }\n\n  // :: (Node) → TableMap\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table))\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name)\n  let width = findWidth(table), height = table.childCount\n  let map = [], mapPos = 0, problems = null, colWidths = []\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row)\n    pos++\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++\n      if (i == rowNode.childCount) break\n      let cellNode = rowNode.child(i), {colspan, rowspan, colwidth} = cellNode.attrs\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({type: \"overlong_rowspan\", pos, n: rowspan - h})\n          break\n        }\n        let start = mapPos + (h * width)\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos\n          else\n            (problems || (problems = [])).push({type: \"collision\", row, pos, n: colspan - w})\n          let colW = colwidth && colwidth[w]\n          if (colW) {\n            let widthIndex = ((start + w) % width) * 2, prev = colWidths[widthIndex]\n            if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {\n              colWidths[widthIndex] = colW\n              colWidths[widthIndex + 1] = 1\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++\n            }\n          }\n        }\n      }\n      mapPos += colspan\n      pos += cellNode.nodeSize\n    }\n    let expectedPos = (row + 1) * width, missing = 0\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++\n    if (missing) (problems || (problems = [])).push({type: \"missing\", row, n: missing})\n    pos++\n  }\n\n  let tableMap = new TableMap(width, height, map, problems), badWidths = false\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true\n  if (badWidths) findBadColWidths(tableMap, colWidths, table)\n\n  return tableMap\n}\n\nfunction findWidth(table) {\n  let width = -1, hasRowSpan = false\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row), rowWidth = 0\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      let prevRow = table.child(j)\n      for (let i = 0; i < prevRow.childCount; i++) {\n        let cell = prevRow.child(i)\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan\n      }\n    }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i)\n      rowWidth += cell.attrs.colspan\n      if (cell.attrs.rowspan > 1) hasRowSpan = true\n    }\n    if (width == -1)\n      width = rowWidth\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth)\n  }\n  return width\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = []\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i]\n    if (seen[pos]) continue\n    seen[pos] = true\n    let node = table.nodeAt(pos), updated = null\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width, colWidth = colWidths[col * 2]\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth\n    }\n    if (updated) map.problems.unshift({type: \"colwidth mismatch\", pos, colwidth: updated})\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice()\n  let result = []\n  for (let i = 0; i < attrs.colspan; i++) result.push(0)\n  return result\n}\n","// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  let widthAttr = dom.getAttribute(\"data-colwidth\")\n  let widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(s => Number(s)) : null\n  let colspan = Number(dom.getAttribute(\"colspan\") || 1)\n  let result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  }\n  for (let prop in extraAttrs) {\n    let getter = extraAttrs[prop].getFromDOM\n    let value = getter && getter(dom)\n    if (value != null) result[prop] = value\n  }\n  return result\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  let attrs = {}\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\")\n  for (let prop in extraAttrs) {\n    let setter = extraAttrs[prop].setDOMAttr\n    if (setter) setter(node.attrs[prop], attrs)\n  }\n  return attrs\n}\n\n// :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nexport function tableNodes(options) {\n  let extraAttrs = options.cellAttributes || {}\n  let cellAttrs = {\n    colspan: {default: 1},\n    rowspan: {default: 1},\n    colwidth: {default: null}\n  }\n  for (let prop in extraAttrs)\n    cellAttrs[prop] = {default: extraAttrs[prop].default}\n\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{tag: \"table\"}],\n      toDOM() { return [\"table\", [\"tbody\", 0]] }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{tag: \"tr\"}],\n      toDOM() { return [\"tr\", 0] }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{tag: \"td\", getAttrs: dom => getCellAttrs(dom, extraAttrs)}],\n      toDOM(node) { return [\"td\", setCellAttrs(node, extraAttrs), 0] }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{tag: \"th\", getAttrs: dom => getCellAttrs(dom, extraAttrs)}],\n      toDOM(node) { return [\"th\", setCellAttrs(node, extraAttrs), 0] }\n    }\n  }\n}\n\nexport function tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {}\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name], role = type.spec.tableRole\n      if (role) result[role] = type\n    }\n  }\n  return result\n}\n","// Various helper function for working with tables\n\nimport {PluginKey} from \"prosemirror-state\"\n\nimport {TableMap} from \"./tablemap\"\nimport {tableNodeTypes} from \"./schema\";\n\nexport const key = new PluginKey(\"selectingCells\")\n\nexport function cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1))\n  return null\n}\n\nexport function cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) { // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === 'header_cell') return $pos.node(d)\n  }\n  return null\n}\n\nexport function isInTable(state) {\n  let $head = state.selection.$head\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true\n  return false\n}\n\nexport function selectionCell(state) {\n  let sel = state.selection\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head)\n}\n\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    let role = after.type.spec.tableRole\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos)\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    let role = before.type.spec.tableRole\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize)\n  }\n}\n\nexport function pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && $pos.nodeAfter\n}\n\nexport function moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize)\n}\n\nexport function inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1)\n}\n\nexport function findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1))\n}\n\nexport function colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1))\n}\n\nexport function nextCell($pos, axis, dir) {\n  let start = $pos.start(-1), map = TableMap.get($pos.node(-1))\n  let moved = map.nextCell($pos.pos - start, axis, dir)\n  return moved == null ? null : $pos.node(0).resolve(start + moved)\n}\n\nexport function setAttr(attrs, name, value) {\n  let result = {}\n  for (let prop in attrs) result[prop] = attrs[prop]\n  result[name] = value\n  return result\n}\n\nexport function removeColSpan(attrs, pos, n=1) {\n  let result = setAttr(attrs, \"colspan\", attrs.colspan - n)\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice()\n    result.colwidth.splice(pos, n)\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null\n  }\n  return result\n}\n\nexport function addColSpan(attrs, pos, n=1) {\n  let result = setAttr(attrs, \"colspan\", attrs.colspan + n)\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice()\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0)\n  }\n  return result\n}\n\nexport function columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false\n  return true\n}\n","// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport {Selection, TextSelection, NodeSelection, SelectionRange} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\nimport {Fragment, Slice} from \"prosemirror-model\"\n\n\nimport {inSameTable, pointsAtCell, setAttr, removeColSpan} from \"./util\"\nimport {TableMap} from \"./tablemap\"\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nexport class CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1)\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    let cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - start)\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start)\n    let ranges = cells.map(pos => {\n      let cell = table.nodeAt(pos), from = pos + start + 1\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size))\n    })\n    super(ranges[0].$from, ranges[0].$to, ranges)\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos))\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos))\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1)\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell)\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell)\n      else\n        return new CellSelection($anchorCell, $headCell)\n    }\n    return TextSelection.between($anchorCell, $headCell)\n  }\n\n  // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1)\n    let rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start)\n    let seen = {}, rows = []\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = []\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        let pos = map.map[index]\n        if (!seen[pos]) {\n          seen[pos] = true\n          let cellRect = map.findCell(pos), cell = table.nodeAt(pos)\n          let extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs\n            if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft)\n            if (extraRight > 0) attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight)\n            if (cellRect.left < rect.left) cell = cell.type.createAndFill(attrs)\n            else cell = cell.type.create(attrs, cell.content)\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(cell.attrs, \"rowspan\", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top))\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs)\n            else cell = cell.type.create(attrs, cell.content)\n          }\n          rowContent.push(cell)\n        }\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)))\n    }\n\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1)\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n    }\n    let sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1)\n    if (sel) tr.setSelection(sel)\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0))\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1)\n    let cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start))\n    for (let i = 0; i < cells.length; i++)\n      f(table.nodeAt(cells[i]), start + cells[i])\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1)\n    if (Math.min(anchorTop, headTop) > 0) return false\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1)\n    let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.left])\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1])\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(start + map.map[headRect.left])\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1])\n    }\n    return new CellSelection($anchorCell, $headCell)\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1)\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start)\n    if (Math.min(anchorLeft, headLeft) > 0) return false\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan\n    return Math.max(anchorRight, headRight) == map.width\n  }\n\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1)\n    let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start)\n    let doc = $anchorCell.node(0)\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width])\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1])\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(start + map.map[headRect.top * map.width])\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1])\n    }\n    return new CellSelection($anchorCell, $headCell)\n  }\n\n  toJSON() {\n    return {type: \"cell\", anchor: this.$anchorCell.pos, head: this.$headCell.pos}\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → CellSelection\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell))\n  }\n\n  getBookmark() { return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos) }\n}\n\nCellSelection.prototype.visible = false\n\nSelection.jsonID(\"cell\", CellSelection)\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head)\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" &&\n        $headCell.parent.type.spec.tableRole == \"row\" &&\n        $anchorCell.index() < $anchorCell.parent.childCount &&\n        $headCell.index() < $headCell.parent.childCount &&\n        inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell)\n    else\n      return Selection.near($headCell, 1)\n  }\n}\n\nexport function drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null\n  let cells = []\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {class: \"selectedCell\"}))\n  })\n  return DecorationSet.create(state.doc, cells)\n}\n\nfunction isCellBoundarySelection({$from, $to}) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false // Cheap elimination\n  let afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole)\n}\n\nfunction isTextSelectionAcrossCells({$from, $to}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0\n}\n\nexport function normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection, doc = (tr || state).doc, normalize, role\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from)\n    } else if (role == \"row\") {\n      let $cell = doc.resolve(sel.from + 1)\n      normalize = CellSelection.rowSelection($cell, $cell)\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node), start = sel.from + 1\n      let lastCell = start + map.map[map.width * map.height - 1]\n      normalize = CellSelection.create(doc, start + 1, lastCell)\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from)\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize)\n  return tr\n}\n","// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Transform} from \"prosemirror-transform\"\n\nimport {setAttr, removeColSpan} from \"./util\"\nimport {TableMap} from \"./tablemap\"\nimport {CellSelection} from \"./cellselection\"\nimport {tableNodeTypes} from \"./schema\"\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nexport function pastedCells(slice) {\n  if (!slice.size) return null\n  let {content, openStart, openEnd} = slice\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == \"table\")) {\n    openStart--\n    openEnd--\n    content = content.firstChild.content\n  }\n  let first = content.firstChild, role = first.type.spec.tableRole\n  let schema = first.type.schema, rows = []\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content\n      let left = i ? 0 : Math.max(0, openStart - 1)\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1)\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content\n      rows.push(cells)\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content)\n  } else {\n    return null\n  }\n  return ensureRectangular(schema, rows)\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  let widths = []\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i]\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let {rowspan, colspan} = row.child(j).attrs\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan\n    }\n  }\n  let width = 0\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r])\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty)\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(), cells = []\n      for (let i = widths[r]; i < width; i++) cells.push(empty)\n      rows[r] = rows[r].append(Fragment.from(cells))\n    }\n  }\n  return {height: rows.length, width, rows}\n}\n\nexport function fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill()\n  let tr = new Transform(node).replace(0, node.content.size, slice)\n  return tr.doc\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nexport function clipCells({width, height, rows}, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [], newRows = []\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row], cells = []\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount)\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content)\n        cells.push(cell)\n        col += cell.attrs.colspan\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan\n      }\n      newRows.push(Fragment.from(cells))\n    }\n    rows = newRows\n    width = newWidth\n  }\n\n  if (height != newHeight) {\n    let newRows = []\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [], source = rows[i % height]\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j)\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(setAttr(cell.attrs, \"rowspan\", Math.max(1, newHeight - cell.attrs.rowspan)), cell.content)\n        cells.push(cell)\n      }\n      newRows.push(Fragment.from(cells))\n    }\n    rows = newRows\n    height = newHeight\n  }\n\n  return {width, height, rows}\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row)\n      rowEnd += rowNode.nodeSize\n      let cells = [], add\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill())\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill())\n      for (let i = map.width; i < width; i++) cells.push(add)\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells)\n    }\n  }\n  if (height > map.height) {\n    let cells = []\n    for (let i = 0, start = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      let header = i >= map.width ? false :\n          table.nodeAt(map.map[start + i]).type == types.header_cell\n      cells.push(header\n                 ? (emptyHead || (emptyHead = types.header_cell.createAndFill()))\n                 : (empty || (empty = types.cell.createAndFill())))\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)), rows = []\n    for (let i = map.height; i < height; i++) rows.push(emptyRow)\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows)\n  }\n  return !!(empty || emptyHead)\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false\n  let found = false\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col, pos = map.map[index]\n    if (map.map[index - map.width] == pos) {\n      found = true\n      let cell = table.nodeAt(pos)\n      let {top: cellTop, left: cellLeft} = map.findCell(pos)\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, \"rowspan\", top - cellTop))\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n                cell.type.createAndFill(setAttr(cell.attrs, \"rowspan\", (cellTop + cell.attrs.rowspan) - top)))\n      col += cell.attrs.colspan - 1\n    }\n  }\n  return found\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false\n  let found = false\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left, pos = map.map[index]\n    if (map.map[index - 1] == pos) {\n      found = true\n      let cell = table.nodeAt(pos), cellLeft = map.colCount(pos)\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start)\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)))\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)))\n      row += cell.attrs.rowspan - 1\n    }\n  }\n  return found\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nexport function insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table)\n  let {top, left} = rect\n  let right = left + cells.width, bottom = top + cells.height\n  let tr = state.tr, mapFrom = 0\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc\n    map = TableMap.get(table)\n    mapFrom = tr.mapping.maps.length\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp()\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp()\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp()\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp()\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp()\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table), to = map.positionAt(row, right, table)\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart),\n               new Slice(cells.rows[row - top], 0, 0))\n  }\n  recomp()\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n                                    tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))))\n  dispatch(tr)\n}\n","// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection} from \"prosemirror-state\"\nimport {keydownHandler} from \"prosemirror-keymap\"\n\nimport {key, nextCell, cellAround, inSameTable,\n        isInTable, selectionCell} from \"./util\"\nimport {CellSelection} from \"./cellselection\"\nimport {TableMap} from \"./tablemap\"\nimport {pastedCells, fitSlice, clipCells, insertCells} from \"./copypaste\"\nimport {tableNodeTypes} from \"./schema\"\n\nexport const handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1),\n\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n\n  \"Backspace\": deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  \"Delete\": deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n})\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView())\n  return true\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir))\n    }\n    if (axis != \"horiz\" && !sel.empty) return false\n    let end = atEndOfCell(view, axis, dir)\n    if (end == null) return false\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir))\n    } else {\n      let $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel\n      if ($next) newSel = Selection.near($next, 1)\n      else if (dir < 0) newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1)\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1)\n      return maybeSetSelection(state, dispatch, newSel)\n    }\n  }\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir)\n      if (end == null) return false\n      sel = new CellSelection(state.doc.resolve(end))\n    }\n    let $head = nextCell(sel.$headCell, axis, dir)\n    if (!$head) return false\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head))\n  }\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection\n  if (!(sel instanceof CellSelection)) return false\n  if (dispatch) {\n    let tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1),\n                   new Slice(baseContent, 0, 0))\n    })\n    if (tr.docChanged) dispatch(tr)\n  }\n  return true\n}\n\nexport function handleTripleClick(view, pos) {\n  let doc = view.state.doc, $cell = cellAround(doc.resolve(pos))\n  if (!$cell) return false\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)))\n  return true\n}\n\nexport function handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false\n  let cells = pastedCells(slice), sel = view.state.selection\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]}\n    let table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1)\n    let rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start)\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top)\n    insertCells(view.state, view.dispatch, start, rect, cells)\n    return true\n  } else if (cells) {\n    let $cell = selectionCell(view.state), start = $cell.start(-1)\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells)\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return\n\n  let startDOMCell = domInCell(view, startEvent.target), $anchor\n  if (startEvent.shiftKey && (view.state.selection instanceof CellSelection)) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent)\n    startEvent.preventDefault()\n  } else if (startEvent.shiftKey && startDOMCell &&\n             ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n             cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent)\n    startEvent.preventDefault()\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event)\n    let starting = key.getState(view.state) == null\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor\n      else return\n    }\n    let selection = new CellSelection($anchor, $head)\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection)\n      if (starting) tr.setMeta(key, $anchor.pos)\n      view.dispatch(tr)\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop)\n    view.root.removeEventListener(\"dragstart\", stop)\n    view.root.removeEventListener(\"mousemove\", move)\n    if (key.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(key, -1))\n  }\n\n  function move(event) {\n    let anchor = key.getState(view.state), $anchor\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor)\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent)\n      if (!$anchor) return stop()\n    }\n    if ($anchor) setCellSelection($anchor, event)\n  }\n  view.root.addEventListener(\"mouseup\", stop)\n  view.root.addEventListener(\"dragstart\", stop)\n  view.root.addEventListener(\"mousemove\", move)\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null\n  let {$head} = view.state.selection\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d)\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      let cellPos = $head.before(d)\n      let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n      return view.endOfTextblock(dirStr) ? cellPos : null\n    }\n  }\n  return null\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") return dom\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (!mousePos) return null\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null\n}\n","// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport {PluginKey} from \"prosemirror-state\"\nimport {TableMap} from \"./tablemap\"\nimport {setAttr, removeColSpan} from \"./util\"\nimport {tableNodeTypes} from \"./schema\"\nimport {key} from \"./util\"\n\nexport const fixTablesKey = new PluginKey(\"fix-tables\")\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount, curSize = cur.childCount\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i)\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1\n        offset += child.nodeSize\n        continue outer\n      }\n    }\n    f(child, offset)\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f)\n    else\n      child.nodesBetween(0, child.content.size, f, offset + 1)\n    offset += child.nodeSize\n  }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nexport function fixTables(state, oldState) {\n  let tr, check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr)\n  }\n  if (!oldState) state.doc.descendants(check)\n  else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check)\n  return tr\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table)\n  if (!map.problems) return tr\n  if (!tr) tr = state.tr\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  let mustAdd = []\n  for (let i = 0; i < map.height; i++) mustAdd.push(0)\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i]\n    if (prob.type == \"collision\") {\n      let cell = table.nodeAt(prob.pos)\n      for (let j = 0; j < cell.attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n))\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n\n    } else if (prob.type == \"overlong_rowspan\") {\n      let cell = table.nodeAt(prob.pos)\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - prob.n))\n    } else if (prob.type == \"colwidth mismatch\") {\n      let cell = table.nodeAt(prob.pos)\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, \"colwidth\", prob.colwidth))\n    }\n  }\n  let first, last\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i\n    last = i\n  }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i)\n    let end = pos + row.nodeSize\n    let add = mustAdd[i]\n    if (add > 0) {\n      let tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole\n      }\n      let nodes = []\n      for (let j = 0; j < add; j++)\n        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill())\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1\n      tr.insert(tr.mapping.map(side), nodes)\n    }\n    pos = end\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true })\n}\n","// This file defines a number of table-related commands.\n\nimport {TextSelection} from \"prosemirror-state\"\nimport {Fragment} from \"prosemirror-model\"\n\nimport {Rect, TableMap} from \"./tablemap\"\nimport {CellSelection} from \"./cellselection\"\nimport {\n  addColSpan,\n  cellAround,\n  cellWrapping,\n  columnIsHeader,\n  isInTable,\n  moveCellForward,\n  removeColSpan,\n  selectionCell,\n  setAttr\n} from \"./util\"\nimport {tableNodeTypes} from \"./schema\"\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nexport function selectedRect(state) {\n  let sel = state.selection, $pos = selectionCell(state)\n  let table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table)\n  let rect\n  if (sel instanceof CellSelection)\n    rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart)\n  else\n    rect = map.findCell($pos.pos - tableStart)\n  rect.tableStart = tableStart\n  rect.map = map\n  rect.table = table\n  return rect\n}\n\n// Add a column at the given position in a table.\nexport function addColumn(tr, {map, tableStart, table}, col) {\n  let refColumn = col > 0 ? -1 : 0\n  if (columnIsHeader(map, table, col + refColumn))\n    refColumn = col == 0 || col == map.width ? null : 0\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index], cell = table.nodeAt(pos)\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null,\n                       addColSpan(cell.attrs, col - map.colCount(pos)))\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1\n    } else {\n      let type = refColumn == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type\n      let pos = map.positionAt(row, col, table)\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill())\n    }\n  }\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nexport function addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addColumn(state.tr, rect, rect.left))\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nexport function addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addColumn(state.tr, rect, rect.right))\n  }\n  return true\n}\n\nexport function removeColumn(tr, {map, table, tableStart}, col) {\n  let mapStart = tr.mapping.maps.length\n  for (let row = 0; row < map.height;) {\n    let index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos)\n    // If this is part of a col-spanning cell\n    if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null,\n                       removeColSpan(cell.attrs, col - map.colCount(pos)))\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos)\n      tr.delete(start, start + cell.nodeSize)\n    }\n    row += cell.attrs.rowspan\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nexport function deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state), tr = state.tr\n    if (rect.left == 0 && rect.right == rect.map.width) return false\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i)\n      if (i == rect.left) break\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc\n      rect.map = TableMap.get(rect.table)\n    }\n    dispatch(tr)\n  }\n  return true\n}\n\nexport function rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false\n  return true\n}\n\nexport function addRow(tr, {map, tableStart, table}, row) {\n  let rowPos = tableStart\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize\n  let cells = [], refRow = row > 0 ? -1 : 0\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      let pos = map.map[index], attrs = table.nodeAt(pos).attrs\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, \"rowspan\", attrs.rowspan + 1))\n      col += attrs.colspan - 1\n    } else {\n      let type = refRow == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type\n      cells.push(type.createAndFill())\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells))\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nexport function addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addRow(state.tr, rect, rect.top))\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nexport function addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state)\n    dispatch(addRow(state.tr, rect, rect.bottom))\n  }\n  return true\n}\n\nexport function removeRow(tr, {map, table, tableStart}, row) {\n  let rowPos = 0\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize\n  let nextRow = rowPos + table.child(row).nodeSize\n\n  let mapFrom = tr.mapping.maps.length\n  tr.delete(rowPos + tableStart, nextRow + tableStart)\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index]\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, \"rowspan\", attrs.rowspan - 1))\n      col += attrs.colspan - 1\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos)\n      let copy = cell.type.create(setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - 1), cell.content)\n      let newPos = map.positionAt(row + 1, col, table)\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy)\n      col += cell.attrs.colspan - 1\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nexport function deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false\n  if (dispatch) {\n    let rect = selectedRect(state), tr = state.tr\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i)\n      if (i == rect.top) break\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc\n      rect.map = TableMap.get(rect.table)\n    }\n    dispatch(tr)\n  }\n  return true\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0\n}\n\nfunction cellsOverlapRectangle({width, height, map}, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1)\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] ||\n        rect.right < width && map[indexRight] == map[indexRight + 1]) return true\n    indexLeft += width; indexRight += width\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] ||\n        rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true\n    indexTop++; indexBottom++\n  }\n  return false\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nexport function mergeCells(state, dispatch) {\n  let sel = state.selection\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false\n  let rect = selectedRect(state), {map} = rect\n  if (cellsOverlapRectangle(map, rect)) return false\n  if (dispatch) {\n    let tr = state.tr, seen = {}, content = Fragment.empty, mergedPos, mergedCell\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos)\n        if (seen[cellPos]) continue\n        seen[cellPos] = true\n        if (mergedPos == null) {\n          mergedPos = cellPos\n          mergedCell = cell\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content)\n          let mapped = tr.mapping.map(cellPos + rect.tableStart)\n          tr.delete(mapped, mapped + cell.nodeSize)\n        }\n      }\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null,\n                     setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, (rect.right - rect.left) - mergedCell.attrs.colspan),\n                             \"rowspan\", rect.bottom - rect.top))\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content)\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)))\n    dispatch(tr)\n  }\n  return true\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nexport function splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node,\n  }) => {\n    return nodeTypes[node.type.spec.tableRole]\n  })(state, dispatch)\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nexport function splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection\n    let cellNode, cellPos\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from)\n      if (!cellNode) return false\n      cellPos = cellAround(sel.$from).pos\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false\n      cellNode = sel.$anchorCell.nodeAfter\n      cellPos = sel.$anchorCell.pos\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {return false}\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, \"rowspan\", 1)\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, \"colspan\", 1)\n      let rect = selectedRect(state), tr = state.tr\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(colwidth ? setAttr(baseAttrs, \"colwidth\", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs)\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table)\n        if (row == rect.top) pos += cellNode.nodeSize\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col}).createAndFill(attrs[i]))\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left}), attrs[0])\n      if (sel instanceof CellSelection)\n        tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),\n                                          lastCell && tr.doc.resolve(lastCell)))\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nexport function setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    let $cell = selectionCell(state)\n    if ($cell.nodeAfter.attrs[name] === value) return false\n    if (dispatch) {\n      let tr = state.tr\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value))\n        })\n      else\n        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value))\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema)\n      let rect = selectedRect(state), tr = state.tr\n      let cells = rect.map.cellsInRect(type == \"column\" ? new Rect(rect.left, 0, rect.right, rect.map.height) :\n                                       type == \"row\" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect)\n      let nodes = cells.map(pos => rect.table.nodeAt(pos))\n      for (let i = 0; i < cells.length; i++) // Remove headers, if any\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs)\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++) // No headers removed, add instead\n        tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs)\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1,\n  })\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i])\n    if (cell && cell.type !== types.header_cell) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nexport function toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false }\n\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type)\n\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema)\n      let rect = selectedRect(state), tr = state.tr\n\n      let isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types)\n      let isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types)\n\n      let isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled :\n                            type === \"row\"    ? isHeaderColumnEnabled : false\n\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0\n\n      let cellsRect = type == \"column\" ? new Rect(0, selectionStartsAt, 1, rect.map.height) :\n                      type == \"row\" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect\n\n      let newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell :\n                    type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell\n\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart\n        const cell = tr.doc.nodeAt(cellPos)\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs)\n        }\n      })\n\n      dispatch(tr)\n    }\n    return true\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nexport let toggleHeaderRow = toggleHeader(\"row\", { useDeprecatedLogic: true })\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nexport let toggleHeaderColumn = toggleHeader(\"column\", { useDeprecatedLogic: true })\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nexport let toggleHeaderCell = toggleHeader(\"cell\", { useDeprecatedLogic: true })\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore\n    if (before) return $cell.pos - before.nodeSize\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      let rowNode = $cell.node(-1).child(row)\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize\n      rowEnd -= rowNode.nodeSize\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize\n    let table = $cell.node(-1)\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      let rowNode = table.child(row)\n      if (rowNode.childCount) return rowStart + 1\n      rowStart += rowNode.nodeSize\n    }\n  }\n}\n\n// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nexport function goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false\n    let cell = findNextCell(selectionCell(state), direction)\n    if (cell == null) return\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell)\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView())\n    }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\nexport function deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d)\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView())\n      return true\n    }\n  }\n  return false\n}\n","export class TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement(\"div\")\n    this.dom.className = \"tableWrapper\"\n    this.table = this.dom.appendChild(document.createElement(\"table\"))\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"))\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n    return true\n  }\n\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target))\n  }\n}\n\nexport function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0, fixedWidth = true\n  let nextDOM = colgroup.firstChild, row = node.firstChild\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let {colspan, colwidth} = row.child(i).attrs\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j]\n      let cssWidth = hasWidth ? hasWidth + \"px\" : \"\"\n      totalWidth += hasWidth || cellMinWidth\n      if (!hasWidth) fixedWidth = false\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth\n        nextDOM = nextDOM.nextSibling\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling\n    nextDOM.parentNode.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\"\n    table.style.minWidth = \"\"\n  } else {\n    table.style.width = \"\"\n    table.style.minWidth = totalWidth + \"px\"\n  }\n}\n","import {Plugin, PluginKey} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\nimport {cellAround, pointsAtCell, setAttr} from \"./util\"\nimport {TableMap} from \"./tablemap\"\nimport {TableView, updateColumns} from \"./tableview\"\nimport {tableNodeTypes} from \"./schema\"\n\nexport const key = new PluginKey(\"tableColumnResizing\")\n\nexport function columnResizing({ handleWidth = 5, cellMinWidth = 25, View = TableView, lastColumnResizable = true } = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] =\n          (node, view) => new View(node, cellMinWidth, view)\n        return new ResizeState(-1, false)\n      },\n      apply(tr, prev) {\n        return prev.apply(tr)\n      }\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state)\n        return pluginState.activeHandle > -1 ? {class: \"resize-cursor\"} : null\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) { handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) },\n        mouseleave(view) { handleMouseLeave(view) },\n        mousedown(view, event) { handleMouseDown(view, event, cellMinWidth) }\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state)\n        if (pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle)\n      },\n\n      nodeViews: {}\n    }\n  })\n  return plugin\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle\n    this.dragging = dragging\n  }\n\n  apply(tr) {\n    let state = this, action = tr.getMeta(key)\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, null)\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging)\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1)\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null\n      state = new ResizeState(handle, state.dragging)\n    }\n    return state\n  }\n}\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  let pluginState = key.getState(view.state)\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target), cell = -1\n    if (target) {\n      let {left, right} = target.getBoundingClientRect()\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\")\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\")\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell)\n        let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n        let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n\n        if (col == map.width - 1) {\n          return\n        }\n      }\n\n      updateHandle(view, cell)\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state)\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1)\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state)\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false\n\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle)\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs)\n  view.dispatch(view.state.tr.setMeta(key, {setDragging: {startX: event.clientX, startWidth: width}}))\n\n  function finish(event) {\n    window.removeEventListener(\"mouseup\", finish)\n    window.removeEventListener(\"mousemove\", move)\n    let pluginState = key.getState(view.state)\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth))\n      view.dispatch(view.state.tr.setMeta(key, {setDragging: null}))\n    }\n  }\n  function move(event) {\n    if (!event.which) return finish(event)\n    let pluginState = key.getState(view.state)\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth)\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth)\n  }\n\n  window.addEventListener(\"mouseup\", finish)\n  window.addEventListener(\"mousemove\", move)\n  event.preventDefault()\n  return true\n}\n\nfunction currentColWidth(view, cellPos, {colspan, colwidth}) {\n  let width = colwidth && colwidth[colwidth.length - 1]\n  if (width) return width\n  let dom = view.domAtPos(cellPos)\n  let node = dom.node.childNodes[dom.offset]\n  let domWidth = node.offsetWidth, parts = colspan\n  if (colwidth) for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n    domWidth -= colwidth[i]\n    parts--\n  }\n  return domWidth / parts\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList.contains(\"ProseMirror\") ? null : target.parentNode\n  return target\n}\n\nfunction edgeCell(view, event, side) {\n  let found = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (!found) return -1\n  let {pos} = found\n  let $cell = cellAround(view.state.doc.resolve(pos))\n  if (!$cell) return -1\n  if (side == \"right\") return $cell.pos\n  let map = TableMap.get($cell.node(-1)), start = $cell.start(-1)\n  let index = map.map.indexOf($cell.pos - start)\n  return index % map.width == 0 ? -1 : start + map.map[index - 1]\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX\n  return Math.max(cellMinWidth, dragging.startWidth + offset)\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, {setHandle: value}))\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell)\n  let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n  let tr = view.state.tr\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue\n    let pos = map.map[mapIndex], {attrs} = table.nodeAt(pos)\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos)\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue\n    let colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan)\n    colwidth[index] = width\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, \"colwidth\", colwidth))\n  }\n  if (tr.docChanged) view.dispatch(tr)\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell)\n  let table = $cell.node(-1), start = $cell.start(-1)\n  let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1\n  let dom = view.domAtPos($cell.start(-1)).node\n  while (dom.nodeName != \"TABLE\") dom = dom.parentNode\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width)\n}\n\nfunction zeroes(n) {\n  let result = []\n  for (let i = 0; i < n; i++) result.push(0)\n  return result\n}\n\nfunction handleDecorations(state, cell) {\n  let decorations = []\n  let $cell = state.doc.resolve(cell)\n  let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1)\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if ((col == map.width || map.map[index] != map.map[index + 1]) &&\n        (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      let cellPos = map.map[index]\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1\n      let dom = document.createElement(\"div\")\n      dom.className = \"column-resize-handle\"\n      decorations.push(Decoration.widget(pos, dom))\n    }\n  }\n  return DecorationSet.create(state.doc, decorations)\n}\n","// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport {Plugin} from \"prosemirror-state\"\n\nimport {handleTripleClick, handleKeyDown, handlePaste, handleMouseDown} from \"./input\"\nimport {key as tableEditingKey} from \"./util\"\nimport {drawCellSelection, normalizeSelection} from \"./cellselection\"\nimport {fixTables, fixTablesKey} from \"./fixtables\"\n\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nexport function tableEditing({ allowTableNodeSelection = false } = {}) {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() { return null },\n      apply(tr, cur) {\n        let set = tr.getMeta(tableEditingKey)\n        if (set != null) return set == -1 ? null : set\n        if (cur == null || !tr.docChanged) return cur\n        let {deleted, pos} = tr.mapping.mapResult(cur)\n        return deleted ? null : pos\n      }\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n\n      createSelectionBetween(view) {\n        if (tableEditingKey.getState(view.state) != null) return view.state.selection\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection)\n    }\n  })\n}\n\nexport {fixTables, handlePaste, fixTablesKey}\nexport {cellAround, isInTable, selectionCell, moveCellForward, inSameTable, findCell, colCount, nextCell, setAttr, pointsAtCell, removeColSpan, addColSpan, columnIsHeader} from \"./util\";\nexport {tableNodes, tableNodeTypes} from \"./schema\"\nexport {CellSelection} from \"./cellselection\"\nexport {TableMap} from \"./tablemap\"\nexport {tableEditingKey};\nexport * from \"./commands\"\nexport {columnResizing, key as columnResizingPluginKey} from \"./columnresizing\"\nexport {updateColumns as updateColumnsOnResize, TableView} from \"./tableview\"\nexport {pastedCells as __pastedCells, insertCells as __insertCells, clipCells as __clipCells} from \"./copypaste\"\n"]},"metadata":{},"sourceType":"module"}