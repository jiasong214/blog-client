{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar prosemirrorState = require('prosemirror-state');\n\nvar prosemirrorModel = require('prosemirror-model');\n\nvar prosemirrorTables = require('prosemirror-tables'); // :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\n\n\nvar removeParentNodeOfType = function removeParentNodeOfType(nodeType) {\n  return function (tr) {\n    var parent = findParentNodeOfType(nodeType)(tr.selection);\n\n    if (parent) {\n      return removeNodeAtPos(parent.pos)(tr);\n    }\n\n    return tr;\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\n\n\nvar replaceParentNodeOfType = function replaceParentNodeOfType(nodeType, content) {\n  return function (tr) {\n    if (!Array.isArray(nodeType)) {\n      nodeType = [nodeType];\n    }\n\n    for (var i = 0, count = nodeType.length; i < count; i++) {\n      var parent = findParentNodeOfType(nodeType[i])(tr.selection);\n\n      if (parent) {\n        var newTr = replaceNodeAtPos(parent.pos, content)(tr);\n\n        if (newTr !== tr) {\n          return newTr;\n        }\n      }\n    }\n\n    return tr;\n  };\n}; // :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\n\n\nvar removeSelectedNode = function removeSelectedNode(tr) {\n  if (isNodeSelection(tr.selection)) {\n    var from = tr.selection.$from.pos;\n    var to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n\n  return tr;\n}; // :: (content: union<ProseMirrorNode, ProseMirrorFragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces selected node with a given `node`, keeping NodeSelection on the new `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\n\n\nvar replaceSelectedNode = function replaceSelectedNode(content) {\n  return function (tr) {\n    if (isNodeSelection(tr.selection)) {\n      var _tr$selection = tr.selection,\n          $from = _tr$selection.$from,\n          $to = _tr$selection.$to;\n\n      if (content instanceof prosemirrorModel.Fragment && $from.parent.canReplace($from.index(), $from.indexAfter(), content) || $from.parent.canReplaceWith($from.index(), $from.indexAfter(), content.type)) {\n        return cloneTr(tr.replaceWith($from.pos, $to.pos, content) // restore node selection\n        .setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve($from.pos))));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (position: number, dir: ?number) → (tr: Transaction) → Transaction\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\n\n\nvar setTextSelection = function setTextSelection(position) {\n  var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return function (tr) {\n    var nextSelection = prosemirrorState.Selection.findFrom(tr.doc.resolve(position), dir, true);\n\n    if (nextSelection) {\n      return tr.setSelection(nextSelection);\n    }\n\n    return tr;\n  };\n};\n\nvar isSelectableNode = function isSelectableNode(node) {\n  return node.type && node.type.spec.selectable;\n};\n\nvar shouldSelectNode = function shouldSelectNode(node) {\n  return isSelectableNode(node) && node.type.isLeaf;\n};\n\nvar setSelection = function setSelection(node, pos, tr) {\n  if (shouldSelectNode(node)) {\n    return tr.setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve(pos)));\n  }\n\n  return setTextSelection(pos)(tr);\n}; // :: (content: union<ProseMirrorNode, Fragment>, position: ?number, tryToReplace?: boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If `tryToReplace` is true and current selection is a NodeSelection, it will replace selected node with inserted content if its allowed by schema.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\n\n\nvar safeInsert = function safeInsert(content, position, tryToReplace) {\n  return function (tr) {\n    var hasPosition = typeof position === 'number';\n    var $from = tr.selection.$from;\n    var $insertPos = hasPosition ? tr.doc.resolve(position) : isNodeSelection(tr.selection) ? tr.doc.resolve($from.pos + 1) : $from;\n    var parent = $insertPos.parent; // try to replace selected node\n\n    if (isNodeSelection(tr.selection) && tryToReplace) {\n      var oldTr = tr;\n      tr = replaceSelectedNode(content)(tr);\n\n      if (oldTr !== tr) {\n        return tr;\n      }\n    } // try to replace an empty paragraph\n\n\n    if (isEmptyParagraph(parent)) {\n      var _oldTr = tr;\n      tr = replaceParentNodeOfType(parent.type, content)(tr);\n\n      if (_oldTr !== tr) {\n        var pos = isSelectableNode(content) ? // for selectable node, selection position would be the position of the replaced parent\n        $insertPos.before($insertPos.depth) : $insertPos.pos;\n        return setSelection(content, pos, tr);\n      }\n    } // given node is allowed at the current cursor position\n\n\n    if (canInsert($insertPos, content)) {\n      tr.insert($insertPos.pos, content);\n\n      var _pos = hasPosition ? $insertPos.pos : isSelectableNode(content) ? // for atom nodes selection position after insertion is the previous pos\n      tr.selection.$anchor.pos - 1 : tr.selection.$anchor.pos;\n\n      return cloneTr(setSelection(content, _pos, tr));\n    } // looking for a place in the doc where the node is allowed\n\n\n    for (var i = $insertPos.depth; i > 0; i--) {\n      var _pos2 = $insertPos.after(i);\n\n      var $pos = tr.doc.resolve(_pos2);\n\n      if (canInsert($pos, content)) {\n        tr.insert(_pos2, content);\n        return cloneTr(setSelection(content, _pos2, tr));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>, type: ?union<NodeType, null>, attrs: ?union<Object, null>, marks?: [Mark]) → (tr: Transaction) → Transaction\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\n\n\nvar setParentNodeMarkup = function setParentNodeMarkup(nodeType, type, attrs, marks) {\n  return function (tr) {\n    var parent = findParentNodeOfType(nodeType)(tr.selection);\n\n    if (parent) {\n      return cloneTr(tr.setNodeMarkup(parent.pos, type, Object.assign({}, parent.node.attrs, attrs), marks));\n    }\n\n    return tr;\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\n\n\nvar selectParentNodeOfType = function selectParentNodeOfType(nodeType) {\n  return function (tr) {\n    if (!isNodeSelection(tr.selection)) {\n      var parent = findParentNodeOfType(nodeType)(tr.selection);\n\n      if (parent) {\n        return cloneTr(tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, parent.pos)));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (tr: Transaction) → Transaction\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\n\n\nvar removeNodeBefore = function removeNodeBefore(tr) {\n  var position = findPositionOfNodeBefore(tr.selection);\n\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n\n  return tr;\n}; // :: (selection: Selection) → boolean\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\n\n\nvar isNodeSelection = function isNodeSelection(selection) {\n  return selection instanceof prosemirrorState.NodeSelection;\n}; // (nodeType: union<NodeType, [NodeType]>) → boolean\n// Checks if the type a given `node` equals to a given `nodeType`.\n\n\nvar equalNodeType = function equalNodeType(nodeType, node) {\n  return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;\n}; // (tr: Transaction) → Transaction\n// Creates a new transaction object from a given transaction\n\n\nvar cloneTr = function cloneTr(tr) {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n}; // (position: number, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the position immediately before the node.\n\n\nvar replaceNodeAtPos = function replaceNodeAtPos(position, content) {\n  return function (tr) {\n    var node = tr.doc.nodeAt(position);\n    var $pos = tr.doc.resolve(position);\n\n    if (canReplace($pos, content)) {\n      tr = tr.replaceWith(position, position + node.nodeSize, content);\n      var start = tr.selection.$from.pos - 1; // put cursor inside of the inserted node\n\n      tr = setTextSelection(Math.max(start, 0), -1)(tr); // move cursor to the start of the node\n\n      tr = setTextSelection(tr.selection.$from.start())(tr);\n      return cloneTr(tr);\n    }\n\n    return tr;\n  };\n}; // ($pos: ResolvedPos, doc: ProseMirrorNode, content: union<ProseMirrorNode, Fragment>, ) → boolean\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\n\n\nvar canReplace = function canReplace($pos, content) {\n  var node = $pos.node($pos.depth);\n  return node && node.type.validContent(content instanceof prosemirrorModel.Fragment ? content : prosemirrorModel.Fragment.from(content));\n}; // (position: number) → (tr: Transaction) → Transaction\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the position immediately before the node.\n\n\nvar removeNodeAtPos = function removeNodeAtPos(position) {\n  return function (tr) {\n    var node = tr.doc.nodeAt(position);\n    return cloneTr(tr.delete(position, position + node.nodeSize));\n  };\n}; // (schema: Schema) → {[key: string]: NodeType}\n// Returns a map where keys are tableRoles and values are NodeTypes.\n\n\nvar tableNodeTypes = function tableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n\n  var roles = {};\n  Object.keys(schema.nodes).forEach(function (type) {\n    var nodeType = schema.nodes[type];\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}; // :: ($pos: ResolvedPos, content: union<ProseMirrorNode, Fragment>) → boolean\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\n\n\nvar canInsert = function canInsert($pos, content) {\n  var index = $pos.index();\n\n  if (content instanceof prosemirrorModel.Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof prosemirrorModel.Node) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n\n  return false;\n}; // (node: ProseMirrorNode) → boolean\n// Checks if a given `node` is an empty paragraph\n\n\nvar isEmptyParagraph = function isEmptyParagraph(node) {\n  return !node || node.type.name === 'paragraph' && node.nodeSize === 2;\n}; // ($pos: ResolvedPos) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table node closest to a given `$pos`.\n//\n// ```javascript\n// const table = findTableClosestToPos(state.doc.resolve(10));\n// ```\n\n\nvar findTableClosestToPos = function findTableClosestToPos($pos) {\n  var predicate = function predicate(node) {\n    return node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);\n  };\n\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\nvar createCell = function createCell(cellType) {\n  var cellContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n\n  return cellType.createAndFill();\n}; // (rect: {left: number, right: number, top: number, bottom: number}) → (selection: Selection) → boolean\n// Checks if a given CellSelection rect is selected\n\n\nvar isRectSelected = function isRectSelected(rect) {\n  return function (selection) {\n    var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));\n    var start = selection.$anchorCell.start(-1);\n    var cells = map.cellsInRect(rect);\n    var selectedCells = map.cellsInRect(map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start));\n\n    for (var i = 0, count = cells.length; i < count; i++) {\n      if (selectedCells.indexOf(cells[i]) === -1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}; // This function transposes an array of array flipping the columns for rows,\n// transposition is a familiar algebra concept;\n// you can get more details here:\n// https://en.wikipedia.org/wiki/Transpose\n//\n// ```javascript\n//\n//  const arr = [\n//    ['a1', 'a2', 'a3'],\n//    ['b1', 'b2', 'b3'],\n//    ['c1', 'c2', 'c3'],\n//    ['d1', 'd2', 'd3'],\n//  ];\n//\n//  const result = transpose(arr);\n//\n//  result === [\n//    ['a1', 'b1', 'c1', 'd1'],\n//    ['a2', 'b2', 'c2', 'd2'],\n//    ['a3', 'b3', 'c3', 'd3'],\n//  ]\n// ```\n\n\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (column) {\n      return column[i];\n    });\n  });\n}; // :: (tableNode: Node) -> Array<Node>\n// This function will transform the table node\n// into a matrix of rows and columns respecting merged cells,\n// for example this table will be convert to the below:\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\n\n\nvar convertTableNodeToArrayOfRows = function convertTableNodeToArrayOfRows(tableNode) {\n  var map = prosemirrorTables.TableMap.get(tableNode);\n  var rows = [];\n\n  for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    var rowCells = [];\n    var seen = {};\n\n    for (var colIndex = 0; colIndex < map.width; colIndex++) {\n      var cellPos = map.map[rowIndex * map.width + colIndex];\n      var cell = tableNode.nodeAt(cellPos);\n      var rect = map.findCell(cellPos);\n\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null);\n        continue;\n      }\n\n      seen[cellPos] = true;\n      rowCells.push(cell);\n    }\n\n    rows.push(rowCells);\n  }\n\n  return rows;\n}; // :: (tableNode: Node, tableArray: Array<Node>) -> Node\n// This function will transform a matrix of nodes\n// into table node respecting merged cells and rows configurations,\n// for example this array will be convert to the table below:\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n\n\nvar convertArrayOfRowsToTableNode = function convertArrayOfRowsToTableNode(tableNode, arrayOfNodes) {\n  var rowsPM = [];\n  var map = prosemirrorTables.TableMap.get(tableNode);\n\n  for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    var row = tableNode.child(rowIndex);\n    var rowCells = [];\n\n    for (var colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex][colIndex]) {\n        continue;\n      }\n\n      var cellPos = map.map[rowIndex * map.width + colIndex];\n      var cell = arrayOfNodes[rowIndex][colIndex];\n      var oldCell = tableNode.nodeAt(cellPos);\n      var newCell = oldCell.type.createChecked(Object.assign({}, cell.attrs), cell.content, cell.marks);\n      rowCells.push(newCell);\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));\n  }\n\n  var newTable = tableNode.type.createChecked(tableNode.attrs, rowsPM, tableNode.marks);\n  return newTable;\n};\n\nvar moveTableColumn = function moveTableColumn(table, indexesOrigin, indexesTarget, direction) {\n  var rows = transpose(convertTableNodeToArrayOfRows(table.node));\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nvar moveTableRow = function moveTableRow(table, indexesOrigin, indexesTarget, direction) {\n  var rows = convertTableNodeToArrayOfRows(table.node);\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nvar moveRowInArrayOfRows = function moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, directionOverride) {\n  var direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n  var rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  var positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  var target = void 0;\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n\n  rows.splice.apply(rows, [target, 0].concat(rowsExtracted));\n  return rows;\n};\n\nvar checkInvalidMovements = function checkInvalidMovements(originIndex, targetIndex, targets, type) {\n  var direction = originIndex > targetIndex ? -1 : 1;\n  var errorMessage = 'Target position is invalid, you can\\'t move the ' + type + ' ' + originIndex + ' to ' + targetIndex + ', the target can\\'t be split. You could use tryToFit option.';\n\n  if (direction === 1) {\n    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (targets.slice(1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  }\n\n  return true;\n}; // :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\n\n\nvar findParentNode = function findParentNode(predicate) {\n  return function (_ref) {\n    var $from = _ref.$from;\n    return findParentNodeClosestToPos($from, predicate);\n  };\n}; // :: ($pos: ResolvedPos, predicate: (node: ProseMirrorNode) → boolean) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\n\n\nvar findParentNodeClosestToPos = function findParentNodeClosestToPos($pos, predicate) {\n  for (var i = $pos.depth; i > 0; i--) {\n    var node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node: node\n      };\n    }\n  }\n}; // :: (predicate: (node: ProseMirrorNode) → boolean, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\n\n\nvar findParentDomRef = function findParentDomRef(predicate, domAtPos) {\n  return function (selection) {\n    var parent = findParentNode(predicate)(selection);\n\n    if (parent) {\n      return findDomRefAtPos(parent.pos, domAtPos);\n    }\n  };\n}; // :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → boolean\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\n\n\nvar hasParentNode = function hasParentNode(predicate) {\n  return function (selection) {\n    return !!findParentNode(predicate)(selection);\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\n\n\nvar findParentNodeOfType = function findParentNodeOfType(nodeType) {\n  return function (selection) {\n    return findParentNode(function (node) {\n      return equalNodeType(nodeType, node);\n    })(selection);\n  };\n}; // :: ($pos: ResolvedPos, nodeType: union<NodeType, [NodeType]>) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\n\n\nvar findParentNodeOfTypeClosestToPos = function findParentNodeOfTypeClosestToPos($pos, nodeType) {\n  return findParentNodeClosestToPos($pos, function (node) {\n    return equalNodeType(nodeType, node);\n  });\n}; // :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → boolean\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\n\n\nvar hasParentNodeOfType = function hasParentNodeOfType(nodeType) {\n  return function (selection) {\n    return hasParentNode(function (node) {\n      return equalNodeType(nodeType, node);\n    })(selection);\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\n\n\nvar findParentDomRefOfType = function findParentDomRefOfType(nodeType, domAtPos) {\n  return function (selection) {\n    return findParentDomRef(function (node) {\n      return equalNodeType(nodeType, node);\n    }, domAtPos)(selection);\n  };\n}; // :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Returns a node of a given `nodeType` if it is selected. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\n\n\nvar findSelectedNodeOfType = function findSelectedNodeOfType(nodeType) {\n  return function (selection) {\n    if (isNodeSelection(selection)) {\n      var node = selection.node,\n          $from = selection.$from;\n\n      if (equalNodeType(nodeType, node)) {\n        return {\n          node: node,\n          pos: $from.pos,\n          depth: $from.depth\n        };\n      }\n    }\n  };\n}; // :: (selection: Selection) → ?number\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\n\n\nvar findPositionOfNodeBefore = function findPositionOfNodeBefore(selection) {\n  var nodeBefore = selection.$from.nodeBefore;\n  var maybeSelection = prosemirrorState.Selection.findFrom(selection.$from, -1);\n\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    var parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n\n    if (parent) {\n      return parent.pos;\n    }\n\n    return maybeSelection.$from.pos;\n  }\n}; // :: (position: number, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → dom.Node\n// Returns DOM reference of a node at a given `position`. If the node type is of type `TEXT_NODE` it will return the reference of the parent node.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\n\n\nvar findDomRefAtPos = function findDomRefAtPos(position, domAtPos) {\n  var dom = domAtPos(position);\n  var node = dom.node.childNodes[dom.offset];\n\n  if (dom.node.nodeType === Node.TEXT_NODE) {\n    return dom.node.parentNode;\n  }\n\n  if (!node || node.nodeType === Node.TEXT_NODE) {\n    return dom.node;\n  }\n\n  return node;\n}; // :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\n\n\nvar flatten = function flatten(node) {\n  var descend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n\n  var result = [];\n  node.descendants(function (child, pos) {\n    result.push({\n      node: child,\n      pos: pos\n    });\n\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n}; // :: (node: ProseMirrorNode, predicate: (node: ProseMirrorNode) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\n\n\nvar findChildren = function findChildren(node, predicate, descend) {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n\n  return flatten(node, descend).filter(function (child) {\n    return predicate(child.node);\n  });\n}; // :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\n\n\nvar findTextNodes = function findTextNodes(node, descend) {\n  return findChildren(node, function (child) {\n    return child.isText;\n  }, descend);\n}; // :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\n\n\nvar findInlineNodes = function findInlineNodes(node, descend) {\n  return findChildren(node, function (child) {\n    return child.isInline;\n  }, descend);\n}; // :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\n\n\nvar findBlockNodes = function findBlockNodes(node, descend) {\n  return findChildren(node, function (child) {\n    return child.isBlock;\n  }, descend);\n}; // :: (node: ProseMirrorNode, predicate: (attrs: ?Object) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\n\n\nvar findChildrenByAttr = function findChildrenByAttr(node, predicate, descend) {\n  return findChildren(node, function (child) {\n    return !!predicate(child.attrs);\n  }, descend);\n}; // :: (node: ProseMirrorNode, nodeType: NodeType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\n\n\nvar findChildrenByType = function findChildrenByType(node, nodeType, descend) {\n  return findChildren(node, function (child) {\n    return child.type === nodeType;\n  }, descend);\n}; // :: (node: ProseMirrorNode, markType: markType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\n\n\nvar findChildrenByMark = function findChildrenByMark(node, markType, descend) {\n  return findChildren(node, function (child) {\n    return markType.isInSet(child.marks);\n  }, descend);\n}; // :: (node: ProseMirrorNode, nodeType: NodeType) → boolean\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\n\n\nvar contains = function contains(node, nodeType) {\n  return !!findChildrenByType(node, nodeType).length;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // :: (selection: Selection) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest table node.\n//\n// ```javascript\n// const table = findTable(selection);\n// ```\n\n\nvar findTable = function findTable(selection) {\n  return findParentNode(function (node) {\n    return node.type.spec.tableRole && node.type.spec.tableRole === 'table';\n  })(selection);\n}; // :: (selection: Selection) → boolean\n// Checks if current selection is a `CellSelection`.\n//\n// ```javascript\n// if (isCellSelection(selection)) {\n//   // ...\n// }\n// ```\n\n\nvar isCellSelection = function isCellSelection(selection) {\n  return selection instanceof prosemirrorTables.CellSelection;\n}; // :: (selection: Selection) → ?{left: number, right: number, top: number, bottom: number}\n// Get the selection rectangle. Returns `undefined` if selection is not a CellSelection.\n//\n// ```javascript\n// const rect = getSelectionRect(selection);\n// ```\n\n\nvar getSelectionRect = function getSelectionRect(selection) {\n  if (!isCellSelection(selection)) {\n    return;\n  }\n\n  var start = selection.$anchorCell.start(-1);\n  var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));\n  return map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start);\n}; // :: (columnIndex: number) → (selection: Selection) → boolean\n// Checks if entire column at index `columnIndex` is selected.\n//\n// ```javascript\n// const className = isColumnSelected(i)(selection) ? 'selected' : '';\n// ```\n\n\nvar isColumnSelected = function isColumnSelected(columnIndex) {\n  return function (selection) {\n    if (isCellSelection(selection)) {\n      var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));\n      return isRectSelected({\n        left: columnIndex,\n        right: columnIndex + 1,\n        top: 0,\n        bottom: map.height\n      })(selection);\n    }\n\n    return false;\n  };\n}; // :: (rowIndex: number) → (selection: Selection) → boolean\n// Checks if entire row at index `rowIndex` is selected.\n//\n// ```javascript\n// const className = isRowSelected(i)(selection) ? 'selected' : '';\n// ```\n\n\nvar isRowSelected = function isRowSelected(rowIndex) {\n  return function (selection) {\n    if (isCellSelection(selection)) {\n      var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));\n      return isRectSelected({\n        left: 0,\n        right: map.width,\n        top: rowIndex,\n        bottom: rowIndex + 1\n      })(selection);\n    }\n\n    return false;\n  };\n}; // :: (selection: Selection) → boolean\n// Checks if entire table is selected\n//\n// ```javascript\n// const className = isTableSelected(selection) ? 'selected' : '';\n// ```\n\n\nvar isTableSelected = function isTableSelected(selection) {\n  if (isCellSelection(selection)) {\n    var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    })(selection);\n  }\n\n  return false;\n}; // :: (columnIndex: union<number, [number]>) → (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a column(s), where `columnIndex` could be a column index or an array of column indexes.\n//\n// ```javascript\n// const cells = getCellsInColumn(i)(selection); // [{node, pos}, {node, pos}]\n// ```\n\n\nvar getCellsInColumn = function getCellsInColumn(columnIndex) {\n  return function (selection) {\n    var table = findTable(selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n      var indexes = Array.isArray(columnIndex) ? columnIndex : Array.from([columnIndex]);\n      return indexes.reduce(function (acc, index) {\n        if (index >= 0 && index <= map.width - 1) {\n          var cells = map.cellsInRect({\n            left: index,\n            right: index + 1,\n            top: 0,\n            bottom: map.height\n          });\n          return acc.concat(cells.map(function (nodePos) {\n            var node = table.node.nodeAt(nodePos);\n            var pos = nodePos + table.start;\n            return {\n              pos: pos,\n              start: pos + 1,\n              node: node\n            };\n          }));\n        }\n      }, []);\n    }\n  };\n}; // :: (rowIndex: union<number, [number]>) → (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a row(s), where `rowIndex` could be a row index or an array of row indexes.\n//\n// ```javascript\n// const cells = getCellsInRow(i)(selection); // [{node, pos}, {node, pos}]\n// ```\n\n\nvar getCellsInRow = function getCellsInRow(rowIndex) {\n  return function (selection) {\n    var table = findTable(selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n      var indexes = Array.isArray(rowIndex) ? rowIndex : Array.from([rowIndex]);\n      return indexes.reduce(function (acc, index) {\n        if (index >= 0 && index <= map.height - 1) {\n          var cells = map.cellsInRect({\n            left: 0,\n            right: map.width,\n            top: index,\n            bottom: index + 1\n          });\n          return acc.concat(cells.map(function (nodePos) {\n            var node = table.node.nodeAt(nodePos);\n            var pos = nodePos + table.start;\n            return {\n              pos: pos,\n              start: pos + 1,\n              node: node\n            };\n          }));\n        }\n      }, []);\n    }\n  };\n}; // :: (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of all cells in a table.\n//\n// ```javascript\n// const cells = getCellsInTable(selection); // [{node, pos}, {node, pos}]\n// ```\n\n\nvar getCellsInTable = function getCellsInTable(selection) {\n  var table = findTable(selection);\n\n  if (table) {\n    var map = prosemirrorTables.TableMap.get(table.node);\n    var cells = map.cellsInRect({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    });\n    return cells.map(function (nodePos) {\n      var node = table.node.nodeAt(nodePos);\n      var pos = nodePos + table.start;\n      return {\n        pos: pos,\n        start: pos + 1,\n        node: node\n      };\n    });\n  }\n};\n\nvar select = function select(type) {\n  return function (index, expand) {\n    return function (tr) {\n      var table = findTable(tr.selection);\n      var isRowSelection = type === 'row';\n\n      if (table) {\n        var map = prosemirrorTables.TableMap.get(table.node); // Check if the index is valid\n\n        if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n          var left = isRowSelection ? 0 : index;\n          var top = isRowSelection ? index : 0;\n          var right = isRowSelection ? map.width : index + 1;\n          var bottom = isRowSelection ? index + 1 : map.height;\n\n          if (expand) {\n            var cell = findCellClosestToPos(tr.selection.$from);\n\n            if (!cell) {\n              return tr;\n            }\n\n            var selRect = map.findCell(cell.pos - table.start);\n\n            if (isRowSelection) {\n              top = Math.min(top, selRect.top);\n              bottom = Math.max(bottom, selRect.bottom);\n            } else {\n              left = Math.min(left, selRect.left);\n              right = Math.max(right, selRect.right);\n            }\n          }\n\n          var cellsInFirstRow = map.cellsInRect({\n            left: left,\n            top: top,\n            right: isRowSelection ? right : left + 1,\n            bottom: isRowSelection ? top + 1 : bottom\n          });\n          var cellsInLastRow = bottom - top === 1 ? cellsInFirstRow : map.cellsInRect({\n            left: isRowSelection ? left : right - 1,\n            top: isRowSelection ? bottom - 1 : top,\n            right: right,\n            bottom: bottom\n          });\n          var head = table.start + cellsInFirstRow[0];\n          var anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];\n          var $head = tr.doc.resolve(head);\n          var $anchor = tr.doc.resolve(anchor);\n          return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));\n        }\n      }\n\n      return tr;\n    };\n  };\n}; // :: (columnIndex: number, expand: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `columnIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectColumn(i)(state.tr)\n// );\n// ```\n\n\nvar selectColumn = select('column'); // :: (rowIndex: number, expand: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `rowIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectRow(i)(state.tr)\n// );\n// ```\n\nvar selectRow = select('row'); // :: (selection: Selection) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on the entire table.\n//\n// ```javascript\n// dispatch(\n//   selectTable(i)(state.tr)\n// );\n// ```\n\nvar selectTable = function selectTable(tr) {\n  var table = findTable(tr.selection);\n\n  if (table) {\n    var _TableMap$get = prosemirrorTables.TableMap.get(table.node),\n        map = _TableMap$get.map;\n\n    if (map && map.length) {\n      var head = table.start + map[0];\n      var anchor = table.start + map[map.length - 1];\n      var $head = tr.doc.resolve(head);\n      var $anchor = tr.doc.resolve(anchor);\n      return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));\n    }\n  }\n\n  return tr;\n}; // :: (cell: {pos: number, node: ProseMirrorNode}, schema: Schema) → (tr: Transaction) → Transaction\n// Returns a new transaction that clears the content of a given `cell`.\n//\n// ```javascript\n// const $pos = state.doc.resolve(13);\n// dispatch(\n//   emptyCell(findCellClosestToPos($pos), state.schema)(state.tr)\n// );\n// ```\n\n\nvar emptyCell = function emptyCell(cell, schema) {\n  return function (tr) {\n    if (cell) {\n      var _tableNodeTypes$cell$ = tableNodeTypes(schema).cell.createAndFill(),\n          content = _tableNodeTypes$cell$.content;\n\n      if (!cell.node.content.eq(content)) {\n        tr.replaceWith(cell.pos + 1, cell.pos + cell.node.nodeSize, content);\n        return cloneTr(tr);\n      }\n    }\n\n    return tr;\n  };\n}; // :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new column at index `columnIndex`.\n//\n// ```javascript\n// dispatch(\n//   addColumnAt(i)(state.tr)\n// );\n// ```\n\n\nvar addColumnAt = function addColumnAt(columnIndex) {\n  return function (tr) {\n    var table = findTable(tr.selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n\n      if (columnIndex >= 0 && columnIndex <= map.width) {\n        return cloneTr(prosemirrorTables.addColumn(tr, {\n          map: map,\n          tableStart: table.start,\n          table: table.node\n        }, columnIndex));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (originRowIndex: number, targetRowIndex: targetColumnIndex, options?: MovementOptions) → (tr: Transaction) → Transaction\n// Returns a new transaction that moves the origin row to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a row to a place\n// where we will need to split a row with merged cells it'll throw an exception, for example:\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n// ```\n//\n// if you try to move the row 0 to the row index 1 with tryToFit false,\n// it'll throw an exception since you can't split the row 1;\n// but if \"tryToFit\" is true, it'll move the row using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `bottom-to-top`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveRow(0, 1, { tryToFit: true })`\n// the result will be:\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// since we could put the row zero on index one,\n// we pushed to the best place to fit the row index 0,\n// in this case, row index 2.\n//\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//\n// If you try to move the row 0 to row index 4 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged rows,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n//  1: Always put the origin after the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveRow(x, y, options)(state.tr)\n// );\n// ```\n\n\nvar moveRow = function moveRow(originRowIndex, targetRowIndex, opts) {\n  return function (tr) {\n    var defaultOptions = {\n      tryToFit: false,\n      direction: 0\n    };\n    var options = Object.assign(defaultOptions, opts);\n    var table = findTable(tr.selection);\n\n    if (!table) {\n      return tr;\n    }\n\n    var _getSelectionRangeInR = getSelectionRangeInRow(originRowIndex)(tr),\n        indexesOriginRow = _getSelectionRangeInR.indexes;\n\n    var _getSelectionRangeInR2 = getSelectionRangeInRow(targetRowIndex)(tr),\n        indexesTargetRow = _getSelectionRangeInR2.indexes;\n\n    if (indexesOriginRow.indexOf(targetRowIndex) > -1) {\n      return tr;\n    }\n\n    if (!options.tryToFit && indexesTargetRow.length > 1) {\n      checkInvalidMovements(originRowIndex, targetRowIndex, indexesTargetRow, 'row');\n    }\n\n    var newTable = moveTableRow(table, indexesOriginRow, indexesTargetRow, options.direction);\n    return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n  };\n}; // :: (originColumnIndex: number, targetColumnIndex: targetColumnIndex, options?: MovementOptions) → (tr: Transaction) → Transaction\n// Returns a new transaction that moves the origin column to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a column to a place\n// where we will need to split a column with merged cells it'll throw an exception, for example:\n//\n// ```\n//    0      1         2\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// if you try to move the column 0 to the column index 1 with tryToFit false,\n// it'll throw an exception since you can't split the column 1;\n// but if \"tryToFit\" is true, it'll move the column using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `right-to-left`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveColumn(0, 1, { tryToFit: true })`\n// the result will be:\n//\n// ```\n//    0       1             2\n// _____________________ _______\n// |      |             |      |\n// |  B1  |     C1      |  A1  |\n// |______|______ ______|______|\n// |             |      |      |\n// |     B2      |      |  A2  |\n// |______ ______|      |______|\n// |      |      |  D1  |      |\n// |  B3  |  C2  |      |  A3  |\n// |______|______|______|______|\n// ```\n//\n// since we could put the column zero on index one,\n// we pushed to the best place to fit the column 0, in this case, column index 2.\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |      |             |      |             |\n//  |  A1  |  B1  |     C1      |  E1  |     F1      |\n//  |______|______|______ ______|______|______ ______|\n//  |      |             |      |             |      |\n//  |  A2  |     B2      |      |     E2      |      |\n//  |______|______ ______|      |______ ______|      |\n//  |      |      |      |  D1  |      |      |  G2  |\n//  |  A3  |  B3  |  C3  |      |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//\n// If you try to move the column 0 to column index 5 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged columns,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |      |             |\n//  |  B1  |     C1      |  A1  |  E1  |     F1      |\n//  |______|______ ______|______|______|______ ______|\n//  |             |      |      |             |      |\n//  |     B2      |      |  A2  |     E2      |      |\n//  |______ ______|      |______|______ ______|      |\n//  |      |      |  D1  |      |      |      |  G2  |\n//  |  B3  |  C3  |      |  A3  |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  1: Always put the origin after the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveColumn(x, y, options)(state.tr)\n// );\n// ```\n\n\nvar moveColumn = function moveColumn(originColumnIndex, targetColumnIndex, opts) {\n  return function (tr) {\n    var defaultOptions = {\n      tryToFit: false,\n      direction: 0\n    };\n    var options = Object.assign(defaultOptions, opts);\n    var table = findTable(tr.selection);\n\n    if (!table) {\n      return tr;\n    }\n\n    var _getSelectionRangeInC = getSelectionRangeInColumn(originColumnIndex)(tr),\n        indexesOriginColumn = _getSelectionRangeInC.indexes;\n\n    var _getSelectionRangeInC2 = getSelectionRangeInColumn(targetColumnIndex)(tr),\n        indexesTargetColumn = _getSelectionRangeInC2.indexes;\n\n    if (indexesOriginColumn.indexOf(targetColumnIndex) > -1) {\n      return tr;\n    }\n\n    if (!options.tryToFit && indexesTargetColumn.length > 1) {\n      checkInvalidMovements(originColumnIndex, targetColumnIndex, indexesTargetColumn, 'column');\n    }\n\n    var newTable = moveTableColumn(table, indexesOriginColumn, indexesTargetColumn, options.direction);\n    return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n  };\n}; // :: (rowIndex: number, clonePreviousRow?: boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new row at index `rowIndex`. Optionally clone the previous row.\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i)(state.tr)\n// );\n// ```\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i, true)(state.tr)\n// );\n// ```\n\n\nvar addRowAt = function addRowAt(rowIndex, clonePreviousRow) {\n  return function (tr) {\n    var table = findTable(tr.selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n      var cloneRowIndex = rowIndex - 1;\n\n      if (clonePreviousRow && cloneRowIndex >= 0) {\n        return cloneTr(cloneRowAt(cloneRowIndex)(tr));\n      }\n\n      if (rowIndex >= 0 && rowIndex <= map.height) {\n        return cloneTr(prosemirrorTables.addRow(tr, {\n          map: map,\n          tableStart: table.start,\n          table: table.node\n        }, rowIndex));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (cloneRowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new row after `cloneRowIndex`, cloning the row attributes at `cloneRowIndex`.\n//\n// ```javascript\n// dispatch(\n//   cloneRowAt(i)(state.tr)\n// );\n// ```\n\n\nvar cloneRowAt = function cloneRowAt(rowIndex) {\n  return function (tr) {\n    var table = findTable(tr.selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n\n      if (rowIndex >= 0 && rowIndex <= map.height) {\n        var tableNode = table.node;\n        var tableNodes = tableNodeTypes(tableNode.type.schema);\n        var rowPos = table.start;\n\n        for (var i = 0; i < rowIndex + 1; i++) {\n          rowPos += tableNode.child(i).nodeSize;\n        }\n\n        var cloneRow = tableNode.child(rowIndex); // Re-create the same nodes with same attrs, dropping the node content.\n\n        var cells = [];\n        var rowWidth = 0;\n        cloneRow.forEach(function (cell) {\n          // If we're copying a row with rowspan somewhere, we dont want to copy that cell\n          // We'll increment its span below.\n          if (cell.attrs.rowspan === 1) {\n            rowWidth += cell.attrs.colspan;\n            cells.push(tableNodes[cell.type.spec.tableRole].createAndFill(cell.attrs, cell.marks));\n          }\n        }); // If a higher row spans past our clone row, bump the higher row to cover this new row too.\n\n        if (rowWidth < map.width) {\n          var rowSpanCells = [];\n\n          var _loop = function _loop(_i) {\n            var foundCells = filterCellsInRow(_i, function (cell, tr) {\n              var rowspan = cell.node.attrs.rowspan;\n              var spanRange = _i + rowspan;\n              return rowspan > 1 && spanRange > rowIndex;\n            })(tr);\n            rowSpanCells.push.apply(rowSpanCells, _toConsumableArray(foundCells));\n          };\n\n          for (var _i = rowIndex; _i >= 0; _i--) {\n            _loop(_i);\n          }\n\n          if (rowSpanCells.length) {\n            rowSpanCells.forEach(function (cell) {\n              tr = setCellAttrs(cell, {\n                rowspan: cell.node.attrs.rowspan + 1\n              })(tr);\n            });\n          }\n        }\n\n        return safeInsert(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(tr);\n      }\n    }\n\n    return tr;\n  };\n}; // :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeColumnAt(i)(state.tr)\n// );\n// ```\n\n\nvar removeColumnAt = function removeColumnAt(columnIndex) {\n  return function (tr) {\n    var table = findTable(tr.selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n\n      if (columnIndex === 0 && map.width === 1) {\n        return removeTable(tr);\n      } else if (columnIndex >= 0 && columnIndex <= map.width) {\n        prosemirrorTables.removeColumn(tr, {\n          map: map,\n          tableStart: table.start,\n          table: table.node\n        }, columnIndex);\n        return cloneTr(tr);\n      }\n    }\n\n    return tr;\n  };\n}; // :: (rowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeRowAt(i)(state.tr)\n// );\n// ```\n\n\nvar removeRowAt = function removeRowAt(rowIndex) {\n  return function (tr) {\n    var table = findTable(tr.selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n\n      if (rowIndex === 0 && map.height === 1) {\n        return removeTable(tr);\n      } else if (rowIndex >= 0 && rowIndex <= map.height) {\n        prosemirrorTables.removeRow(tr, {\n          map: map,\n          tableStart: table.start,\n          table: table.node\n        }, rowIndex);\n        return cloneTr(tr);\n      }\n    }\n\n    return tr;\n  };\n}; // :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes a table node if the cursor is inside of it.\n//\n// ```javascript\n// dispatch(\n//   removeTable(state.tr)\n// );\n// ```\n\n\nvar removeTable = function removeTable(tr) {\n  var $from = tr.selection.$from;\n\n  for (var depth = $from.depth; depth > 0; depth--) {\n    var node = $from.node(depth);\n\n    if (node.type.spec.tableRole === 'table') {\n      return cloneTr(tr.delete($from.before(depth), $from.after(depth)));\n    }\n  }\n\n  return tr;\n}; // :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected columns.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedColumns(state.tr)\n// );\n// ```\n\n\nvar removeSelectedColumns = function removeSelectedColumns(tr) {\n  var selection = tr.selection;\n\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n\n  if (isCellSelection(selection)) {\n    var table = findTable(selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);\n\n      if (rect.left == 0 && rect.right == map.width) {\n        return false;\n      }\n\n      var pmTableRect = Object.assign({}, rect, {\n        map: map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (var i = pmTableRect.right - 1;; i--) {\n        prosemirrorTables.removeColumn(tr, pmTableRect, i);\n\n        if (i === pmTableRect.left) {\n          break;\n        }\n\n        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;\n        pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);\n      }\n\n      return cloneTr(tr);\n    }\n  }\n\n  return tr;\n}; // :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected rows.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedRows(state.tr)\n// );\n// ```\n\n\nvar removeSelectedRows = function removeSelectedRows(tr) {\n  var selection = tr.selection;\n\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n\n  if (isCellSelection(selection)) {\n    var table = findTable(selection);\n\n    if (table) {\n      var map = prosemirrorTables.TableMap.get(table.node);\n      var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);\n\n      if (rect.top == 0 && rect.bottom == map.height) {\n        return false;\n      }\n\n      var pmTableRect = Object.assign({}, rect, {\n        map: map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (var i = pmTableRect.bottom - 1;; i--) {\n        prosemirrorTables.removeRow(tr, pmTableRect, i);\n\n        if (i === pmTableRect.top) {\n          break;\n        }\n\n        pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;\n        pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);\n      }\n\n      return cloneTr(tr);\n    }\n  }\n\n  return tr;\n}; // :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeColumnClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\n\n\nvar removeColumnClosestToPos = function removeColumnClosestToPos($pos) {\n  return function (tr) {\n    var rect = findCellRectClosestToPos($pos);\n\n    if (rect) {\n      return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));\n    }\n\n    return tr;\n  };\n}; // :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeRowClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\n\n\nvar removeRowClosestToPos = function removeRowClosestToPos($pos) {\n  return function (tr) {\n    var rect = findCellRectClosestToPos($pos);\n\n    if (rect) {\n      return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));\n    }\n\n    return tr;\n  };\n}; // :: (columnIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) → Transaction, setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a column at a given `columnIndex`.\n// It will set the selection into the last cell of the column if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInColumn(0, (cell, tr) => emptyCell(cell, state.schema)(tr))(state.tr)\n// );\n// ```\n\n\nvar forEachCellInColumn = function forEachCellInColumn(columnIndex, cellTransform, setCursorToLastCell) {\n  return function (tr) {\n    var cells = getCellsInColumn(columnIndex)(tr.selection);\n\n    if (cells) {\n      for (var i = cells.length - 1; i >= 0; i--) {\n        tr = cellTransform(cells[i], tr);\n      }\n\n      if (setCursorToLastCell) {\n        var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n        tr.setSelection(prosemirrorState.Selection.near($pos));\n      }\n\n      return cloneTr(tr);\n    }\n\n    return tr;\n  };\n}; // :: (rowIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) → Transaction, setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a row at a given `rowIndex`.\n// It will set the selection into the last cell of the row if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInRow(0, (cell, tr) => setCellAttrs(cell, { background: 'red' })(tr))(state.tr)\n// );\n// ```\n\n\nvar forEachCellInRow = function forEachCellInRow(rowIndex, cellTransform, setCursorToLastCell) {\n  return function (tr) {\n    var cells = getCellsInRow(rowIndex)(tr.selection);\n\n    if (cells) {\n      for (var i = cells.length - 1; i >= 0; i--) {\n        tr = cellTransform(cells[i], tr);\n      }\n\n      if (setCursorToLastCell) {\n        var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n        tr.setSelection(prosemirrorState.Selection.near($pos));\n      }\n    }\n\n    return tr;\n  };\n}; // :: (cell: {pos: number, start: number, node: ProseMirrorNode}, attrs: Object) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets given `attrs` to a given `cell`.\n//\n// ```javascript\n// dispatch(\n//   setCellAttrs(findCellClosestToPos($pos), { background: 'blue' })(tr);\n// );\n// ```\n\n\nvar setCellAttrs = function setCellAttrs(cell, attrs) {\n  return function (tr) {\n    if (cell) {\n      tr.setNodeMarkup(cell.pos, null, Object.assign({}, cell.node.attrs, attrs));\n      return cloneTr(tr);\n    }\n\n    return tr;\n  };\n}; // :: (schema: Schema, rowsCount: ?number, colsCount: ?number, withHeaderRow: ?boolean, cellContent: ?Node) → Node\n// Returns a table node of a given size.\n// `withHeaderRow` defines whether the first row of the table will be a header row.\n// `cellContent` defines the content of each cell.\n//\n// ```javascript\n// const table = createTable(state.schema); // 3x3 table node\n// dispatch(\n//   tr.replaceSelectionWith(table).scrollIntoView()\n// );\n// ```\n\n\nvar createTable = function createTable(schema) {\n  var rowsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var colsCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  var withHeaderRow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var cellContent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var _tableNodeTypes = tableNodeTypes(schema),\n      tableCell = _tableNodeTypes.cell,\n      tableHeader = _tableNodeTypes.header_cell,\n      tableRow = _tableNodeTypes.row,\n      table = _tableNodeTypes.table;\n\n  var cells = [];\n  var headerCells = [];\n\n  for (var i = 0; i < colsCount; i++) {\n    cells.push(createCell(tableCell, cellContent));\n\n    if (withHeaderRow) {\n      headerCells.push(createCell(tableHeader, cellContent));\n    }\n  }\n\n  var rows = [];\n\n  for (var _i2 = 0; _i2 < rowsCount; _i2++) {\n    rows.push(tableRow.createChecked(null, withHeaderRow && _i2 === 0 ? headerCells : cells));\n  }\n\n  return table.createChecked(null, rows);\n}; // :: ($pos: ResolvedPos) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table cell or a table header node closest to a given `$pos`.\n//\n// ```javascript\n// const cell = findCellClosestToPos(state.selection.$from);\n// ```\n\n\nvar findCellClosestToPos = function findCellClosestToPos($pos) {\n  var predicate = function predicate(node) {\n    return node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);\n  };\n\n  return findParentNodeClosestToPos($pos, predicate);\n}; // :: ($pos: ResolvedPos) → ?{left: number, top: number, right: number, bottom: number}\n// Returns the rectangle spanning a cell closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   findCellRectClosestToPos(state.selection.$from)\n// );\n// ```\n\n\nvar findCellRectClosestToPos = function findCellRectClosestToPos($pos) {\n  var cell = findCellClosestToPos($pos);\n\n  if (cell) {\n    var table = findTableClosestToPos($pos);\n    var map = prosemirrorTables.TableMap.get(table.node);\n    var cellPos = cell.pos - table.start;\n    return map.rectBetween(cellPos, cellPos);\n  }\n};\n\nvar filterCellsInRow = function filterCellsInRow(rowIndex, predicate) {\n  return function (tr) {\n    var foundCells = [];\n    var cells = getCellsInRow(rowIndex)(tr.selection);\n\n    if (cells) {\n      for (var j = cells.length - 1; j >= 0; j--) {\n        if (predicate(cells[j], tr)) {\n          foundCells.push(cells[j]);\n        }\n      }\n    }\n\n    return foundCells;\n  };\n}; // :: (columnIndex: number) → (tr: Transaction) → {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a column at index `columnIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInColumn(3)(state.tr);\n// ```\n\n\nvar getSelectionRangeInColumn = function getSelectionRangeInColumn(columnIndex) {\n  return function (tr) {\n    var startIndex = columnIndex;\n    var endIndex = columnIndex; // looking for selection start column (startIndex)\n\n    var _loop2 = function _loop2(i) {\n      var cells = getCellsInColumn(i)(tr.selection);\n\n      if (cells) {\n        cells.forEach(function (cell) {\n          var maybeEndIndex = cell.node.attrs.colspan + i - 1;\n\n          if (maybeEndIndex >= startIndex) {\n            startIndex = i;\n          }\n\n          if (maybeEndIndex > endIndex) {\n            endIndex = maybeEndIndex;\n          }\n        });\n      }\n    };\n\n    for (var i = columnIndex; i >= 0; i--) {\n      _loop2(i);\n    } // looking for selection end column (endIndex)\n\n\n    var _loop3 = function _loop3(i) {\n      var cells = getCellsInColumn(i)(tr.selection);\n\n      if (cells) {\n        cells.forEach(function (cell) {\n          var maybeEndIndex = cell.node.attrs.colspan + i - 1;\n\n          if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n            endIndex = maybeEndIndex;\n          }\n        });\n      }\n    };\n\n    for (var i = columnIndex; i <= endIndex; i++) {\n      _loop3(i);\n    } // filter out columns without cells (where all rows have colspan > 1 in the same column)\n\n\n    var indexes = [];\n\n    for (var i = startIndex; i <= endIndex; i++) {\n      var maybeCells = getCellsInColumn(i)(tr.selection);\n\n      if (maybeCells && maybeCells.length) {\n        indexes.push(i);\n      }\n    }\n\n    startIndex = indexes[0];\n    endIndex = indexes[indexes.length - 1];\n    var firstSelectedColumnCells = getCellsInColumn(startIndex)(tr.selection);\n    var firstRowCells = getCellsInRow(0)(tr.selection);\n    var $anchor = tr.doc.resolve(firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos);\n    var headCell = void 0;\n\n    for (var _i3 = endIndex; _i3 >= startIndex; _i3--) {\n      var columnCells = getCellsInColumn(_i3)(tr.selection);\n\n      if (columnCells && columnCells.length) {\n        for (var j = firstRowCells.length - 1; j >= 0; j--) {\n          if (firstRowCells[j].pos === columnCells[0].pos) {\n            headCell = columnCells[0];\n            break;\n          }\n        }\n\n        if (headCell) {\n          break;\n        }\n      }\n    }\n\n    var $head = tr.doc.resolve(headCell.pos);\n    return {\n      $anchor: $anchor,\n      $head: $head,\n      indexes: indexes\n    };\n  };\n}; // :: (rowIndex: number) → (tr: Transaction) → {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a row at index `rowIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInRow(3)(state.tr);\n// ```\n\n\nvar getSelectionRangeInRow = function getSelectionRangeInRow(rowIndex) {\n  return function (tr) {\n    var startIndex = rowIndex;\n    var endIndex = rowIndex; // looking for selection start row (startIndex)\n\n    var _loop4 = function _loop4(i) {\n      var cells = getCellsInRow(i)(tr.selection);\n      cells.forEach(function (cell) {\n        var maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    };\n\n    for (var i = rowIndex; i >= 0; i--) {\n      _loop4(i);\n    } // looking for selection end row (endIndex)\n\n\n    var _loop5 = function _loop5(i) {\n      var cells = getCellsInRow(i)(tr.selection);\n      cells.forEach(function (cell) {\n        var maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n\n        if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    };\n\n    for (var i = rowIndex; i <= endIndex; i++) {\n      _loop5(i);\n    } // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n\n\n    var indexes = [];\n\n    for (var i = startIndex; i <= endIndex; i++) {\n      var maybeCells = getCellsInRow(i)(tr.selection);\n\n      if (maybeCells && maybeCells.length) {\n        indexes.push(i);\n      }\n    }\n\n    startIndex = indexes[0];\n    endIndex = indexes[indexes.length - 1];\n    var firstSelectedRowCells = getCellsInRow(startIndex)(tr.selection);\n    var firstColumnCells = getCellsInColumn(0)(tr.selection);\n    var $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1].pos);\n    var headCell = void 0;\n\n    for (var _i4 = endIndex; _i4 >= startIndex; _i4--) {\n      var rowCells = getCellsInRow(_i4)(tr.selection);\n\n      if (rowCells && rowCells.length) {\n        for (var j = firstColumnCells.length - 1; j >= 0; j--) {\n          if (firstColumnCells[j].pos === rowCells[0].pos) {\n            headCell = rowCells[0];\n            break;\n          }\n        }\n\n        if (headCell) {\n          break;\n        }\n      }\n    }\n\n    var $head = tr.doc.resolve(headCell.pos);\n    return {\n      $anchor: $anchor,\n      $head: $head,\n      indexes: indexes\n    };\n  };\n};\n\nexports.isNodeSelection = isNodeSelection;\nexports.canInsert = canInsert;\nexports.convertTableNodeToArrayOfRows = convertTableNodeToArrayOfRows;\nexports.convertArrayOfRowsToTableNode = convertArrayOfRowsToTableNode;\nexports.findParentNode = findParentNode;\nexports.findParentNodeClosestToPos = findParentNodeClosestToPos;\nexports.findParentDomRef = findParentDomRef;\nexports.hasParentNode = hasParentNode;\nexports.findParentNodeOfType = findParentNodeOfType;\nexports.findParentNodeOfTypeClosestToPos = findParentNodeOfTypeClosestToPos;\nexports.hasParentNodeOfType = hasParentNodeOfType;\nexports.findParentDomRefOfType = findParentDomRefOfType;\nexports.findSelectedNodeOfType = findSelectedNodeOfType;\nexports.findPositionOfNodeBefore = findPositionOfNodeBefore;\nexports.findDomRefAtPos = findDomRefAtPos;\nexports.flatten = flatten;\nexports.findChildren = findChildren;\nexports.findTextNodes = findTextNodes;\nexports.findInlineNodes = findInlineNodes;\nexports.findBlockNodes = findBlockNodes;\nexports.findChildrenByAttr = findChildrenByAttr;\nexports.findChildrenByType = findChildrenByType;\nexports.findChildrenByMark = findChildrenByMark;\nexports.contains = contains;\nexports.findTable = findTable;\nexports.isCellSelection = isCellSelection;\nexports.getSelectionRect = getSelectionRect;\nexports.isColumnSelected = isColumnSelected;\nexports.isRowSelected = isRowSelected;\nexports.isTableSelected = isTableSelected;\nexports.getCellsInColumn = getCellsInColumn;\nexports.getCellsInRow = getCellsInRow;\nexports.getCellsInTable = getCellsInTable;\nexports.selectColumn = selectColumn;\nexports.selectRow = selectRow;\nexports.selectTable = selectTable;\nexports.emptyCell = emptyCell;\nexports.addColumnAt = addColumnAt;\nexports.moveRow = moveRow;\nexports.moveColumn = moveColumn;\nexports.addRowAt = addRowAt;\nexports.cloneRowAt = cloneRowAt;\nexports.removeColumnAt = removeColumnAt;\nexports.removeRowAt = removeRowAt;\nexports.removeTable = removeTable;\nexports.removeSelectedColumns = removeSelectedColumns;\nexports.removeSelectedRows = removeSelectedRows;\nexports.removeColumnClosestToPos = removeColumnClosestToPos;\nexports.removeRowClosestToPos = removeRowClosestToPos;\nexports.forEachCellInColumn = forEachCellInColumn;\nexports.forEachCellInRow = forEachCellInRow;\nexports.setCellAttrs = setCellAttrs;\nexports.createTable = createTable;\nexports.findCellClosestToPos = findCellClosestToPos;\nexports.findCellRectClosestToPos = findCellRectClosestToPos;\nexports.getSelectionRangeInColumn = getSelectionRangeInColumn;\nexports.getSelectionRangeInRow = getSelectionRangeInRow;\nexports.removeParentNodeOfType = removeParentNodeOfType;\nexports.replaceParentNodeOfType = replaceParentNodeOfType;\nexports.removeSelectedNode = removeSelectedNode;\nexports.replaceSelectedNode = replaceSelectedNode;\nexports.setTextSelection = setTextSelection;\nexports.safeInsert = safeInsert;\nexports.setParentNodeMarkup = setParentNodeMarkup;\nexports.selectParentNodeOfType = selectParentNodeOfType;\nexports.removeNodeBefore = removeNodeBefore;","map":{"version":3,"sources":["../src/transforms.js","../src/helpers.js","../src/selection.js","../src/node.js","../src/table.js"],"names":["removeParentNodeOfType","parent","findParentNodeOfType","tr","removeNodeAtPos","replaceParentNodeOfType","Array","i","count","nodeType","newTr","replaceNodeAtPos","removeSelectedNode","isNodeSelection","from","to","cloneTr","replaceSelectedNode","$from","$to","content","Fragment","NodeSelection","setTextSelection","dir","nextSelection","Selection","isSelectableNode","node","shouldSelectNode","setSelection","safeInsert","hasPosition","$insertPos","oldTr","isEmptyParagraph","pos","canInsert","$pos","setParentNodeMarkup","Object","selectParentNodeOfType","removeNodeBefore","position","findPositionOfNodeBefore","selection","equalNodeType","Date","canReplace","start","Math","tableNodeTypes","schema","roles","index","PMNode","findTableClosestToPos","predicate","findParentNodeClosestToPos","createCell","cellContent","cellType","isRectSelected","map","TableMap","cells","selectedCells","transpose","column","convertTableNodeToArrayOfRows","rows","rowIndex","rowCells","seen","colIndex","cellPos","cell","tableNode","rect","convertArrayOfRowsToTableNode","rowsPM","row","arrayOfNodes","oldCell","newCell","newTable","moveTableColumn","table","moveRowInArrayOfRows","moveTableRow","direction","indexesOrigin","indexesTarget","rowsExtracted","positionOffset","target","directionOverride","checkInvalidMovements","originIndex","errorMessage","targets","findParentNode","findParentDomRef","findDomRefAtPos","hasParentNode","findParentNodeOfTypeClosestToPos","hasParentNodeOfType","findParentDomRefOfType","findSelectedNodeOfType","depth","nodeBefore","maybeSelection","dom","domAtPos","Node","flatten","descend","result","findChildren","child","findTextNodes","findInlineNodes","findBlockNodes","findChildrenByAttr","findChildrenByType","findChildrenByMark","markType","contains","findTable","isCellSelection","CellSelection","getSelectionRect","isColumnSelected","columnIndex","height","isRowSelected","isTableSelected","getCellsInColumn","indexes","nodePos","getCellsInRow","getCellsInTable","select","isRowSelection","type","left","top","right","bottom","findCellClosestToPos","selRect","cellsInFirstRow","cellsInLastRow","head","anchor","$head","$anchor","selectColumn","selectRow","selectTable","emptyCell","addColumnAt","moveRow","defaultOptions","tryToFit","options","indexesOriginRow","getSelectionRangeInRow","indexesTargetRow","moveColumn","indexesOriginColumn","getSelectionRangeInColumn","indexesTargetColumn","addRowAt","cloneRowIndex","clonePreviousRow","cloneRowAt","tableNodes","rowPos","cloneRow","rowWidth","rowSpanCells","foundCells","rowspan","spanRange","removeColumnAt","removeTable","removeRowAt","removeSelectedColumns","pmTableRect","removeSelectedRows","removeColumnClosestToPos","findCellRectClosestToPos","removeRowClosestToPos","forEachCellInColumn","cellTransform","forEachCellInRow","setCellAttrs","createTable","rowsCount","colsCount","withHeaderRow","tableCell","tableHeader","tableRow","headerCells","filterCellsInRow","j","startIndex","endIndex","maybeEndIndex","maybeCells","firstSelectedColumnCells","firstRowCells","headCell","columnCells","firstSelectedRowCells","firstColumnCells"],"mappings":"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","sourcesContent":["import { NodeSelection, Selection } from 'prosemirror-state';\nimport { Fragment } from 'prosemirror-model';\nimport { findParentNodeOfType, findPositionOfNodeBefore } from './selection';\nimport {\n  cloneTr,\n  isNodeSelection,\n  replaceNodeAtPos,\n  removeNodeAtPos,\n  canInsert,\n  isEmptyParagraph\n} from './helpers';\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\nexport const removeParentNodeOfType = nodeType => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return removeNodeAtPos(parent.pos)(tr);\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\nexport const replaceParentNodeOfType = (nodeType, content) => tr => {\n  if (!Array.isArray(nodeType)) {\n    nodeType = [nodeType];\n  }\n  for (let i = 0, count = nodeType.length; i < count; i++) {\n    const parent = findParentNodeOfType(nodeType[i])(tr.selection);\n    if (parent) {\n      const newTr = replaceNodeAtPos(parent.pos, content)(tr);\n      if (newTr !== tr) {\n        return newTr;\n      }\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\nexport const removeSelectedNode = tr => {\n  if (isNodeSelection(tr.selection)) {\n    const from = tr.selection.$from.pos;\n    const to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n  return tr;\n};\n\n// :: (content: union<ProseMirrorNode, ProseMirrorFragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces selected node with a given `node`, keeping NodeSelection on the new `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\nexport const replaceSelectedNode = content => tr => {\n  if (isNodeSelection(tr.selection)) {\n    const { $from, $to } = tr.selection;\n    if (\n      (content instanceof Fragment &&\n        $from.parent.canReplace($from.index(), $from.indexAfter(), content)) ||\n      $from.parent.canReplaceWith(\n        $from.index(),\n        $from.indexAfter(),\n        content.type\n      )\n    ) {\n      return cloneTr(\n        tr\n          .replaceWith($from.pos, $to.pos, content)\n          // restore node selection\n          .setSelection(new NodeSelection(tr.doc.resolve($from.pos)))\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (position: number, dir: ?number) → (tr: Transaction) → Transaction\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\nexport const setTextSelection = (position, dir = 1) => tr => {\n  const nextSelection = Selection.findFrom(tr.doc.resolve(position), dir, true);\n  if (nextSelection) {\n    return tr.setSelection(nextSelection);\n  }\n  return tr;\n};\n\nconst isSelectableNode = node => node.type && node.type.spec.selectable;\nconst shouldSelectNode = node => isSelectableNode(node) && node.type.isLeaf;\n\nconst setSelection = (node, pos, tr) => {\n  if (shouldSelectNode(node)) {\n    return tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));\n  }\n  return setTextSelection(pos)(tr);\n};\n\n// :: (content: union<ProseMirrorNode, Fragment>, position: ?number, tryToReplace?: boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If `tryToReplace` is true and current selection is a NodeSelection, it will replace selected node with inserted content if its allowed by schema.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\nexport const safeInsert = (content, position, tryToReplace) => tr => {\n  const hasPosition = typeof position === 'number';\n  const { $from } = tr.selection;\n  const $insertPos = hasPosition\n    ? tr.doc.resolve(position)\n    : isNodeSelection(tr.selection)\n    ? tr.doc.resolve($from.pos + 1)\n    : $from;\n  const { parent } = $insertPos;\n\n  // try to replace selected node\n  if (isNodeSelection(tr.selection) && tryToReplace) {\n    const oldTr = tr;\n    tr = replaceSelectedNode(content)(tr);\n    if (oldTr !== tr) {\n      return tr;\n    }\n  }\n\n  // try to replace an empty paragraph\n  if (isEmptyParagraph(parent)) {\n    const oldTr = tr;\n    tr = replaceParentNodeOfType(parent.type, content)(tr);\n    if (oldTr !== tr) {\n      const pos = isSelectableNode(content)\n        ? // for selectable node, selection position would be the position of the replaced parent\n          $insertPos.before($insertPos.depth)\n        : $insertPos.pos;\n      return setSelection(content, pos, tr);\n    }\n  }\n\n  // given node is allowed at the current cursor position\n  if (canInsert($insertPos, content)) {\n    tr.insert($insertPos.pos, content);\n    const pos = hasPosition\n      ? $insertPos.pos\n      : isSelectableNode(content)\n      ? // for atom nodes selection position after insertion is the previous pos\n        tr.selection.$anchor.pos - 1\n      : tr.selection.$anchor.pos;\n    return cloneTr(setSelection(content, pos, tr));\n  }\n\n  // looking for a place in the doc where the node is allowed\n  for (let i = $insertPos.depth; i > 0; i--) {\n    const pos = $insertPos.after(i);\n    const $pos = tr.doc.resolve(pos);\n    if (canInsert($pos, content)) {\n      tr.insert(pos, content);\n      return cloneTr(setSelection(content, pos, tr));\n    }\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, type: ?union<NodeType, null>, attrs: ?union<Object, null>, marks?: [Mark]) → (tr: Transaction) → Transaction\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\nexport const setParentNodeMarkup = (nodeType, type, attrs, marks) => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return cloneTr(\n      tr.setNodeMarkup(\n        parent.pos,\n        type,\n        Object.assign({}, parent.node.attrs, attrs),\n        marks\n      )\n    );\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\nexport const selectParentNodeOfType = nodeType => tr => {\n  if (!isNodeSelection(tr.selection)) {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return cloneTr(tr.setSelection(NodeSelection.create(tr.doc, parent.pos)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\nexport const removeNodeBefore = tr => {\n  const position = findPositionOfNodeBefore(tr.selection);\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n  return tr;\n};\n","import { NodeSelection } from 'prosemirror-state';\nimport { Fragment, Node as PMNode } from 'prosemirror-model';\nimport { TableMap } from 'prosemirror-tables';\nimport { setTextSelection } from './transforms';\nimport { findParentNodeClosestToPos } from './selection';\n\n// :: (selection: Selection) → boolean\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\nexport const isNodeSelection = selection => {\n  return selection instanceof NodeSelection;\n};\n\n// (nodeType: union<NodeType, [NodeType]>) → boolean\n// Checks if the type a given `node` equals to a given `nodeType`.\nexport const equalNodeType = (nodeType, node) => {\n  return (\n    (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) ||\n    node.type === nodeType\n  );\n};\n\n// (tr: Transaction) → Transaction\n// Creates a new transaction object from a given transaction\nexport const cloneTr = tr => {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\n// (position: number, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the position immediately before the node.\nexport const replaceNodeAtPos = (position, content) => tr => {\n  const node = tr.doc.nodeAt(position);\n  const $pos = tr.doc.resolve(position);\n  if (canReplace($pos, content)) {\n    tr = tr.replaceWith(position, position + node.nodeSize, content);\n    const start = tr.selection.$from.pos - 1;\n    // put cursor inside of the inserted node\n    tr = setTextSelection(Math.max(start, 0), -1)(tr);\n    // move cursor to the start of the node\n    tr = setTextSelection(tr.selection.$from.start())(tr);\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// ($pos: ResolvedPos, doc: ProseMirrorNode, content: union<ProseMirrorNode, Fragment>, ) → boolean\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\nexport const canReplace = ($pos, content) => {\n  const node = $pos.node($pos.depth);\n  return (\n    node &&\n    node.type.validContent(\n      content instanceof Fragment ? content : Fragment.from(content)\n    )\n  );\n};\n\n// (position: number) → (tr: Transaction) → Transaction\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the position immediately before the node.\nexport const removeNodeAtPos = position => tr => {\n  const node = tr.doc.nodeAt(position);\n  return cloneTr(tr.delete(position, position + node.nodeSize));\n};\n\n// (schema: Schema) → {[key: string]: NodeType}\n// Returns a map where keys are tableRoles and values are NodeTypes.\nexport const tableNodeTypes = schema => {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n};\n\n// :: ($pos: ResolvedPos, content: union<ProseMirrorNode, Fragment>) → boolean\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\nexport const canInsert = ($pos, content) => {\n  const index = $pos.index();\n\n  if (content instanceof Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof PMNode) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n  return false;\n};\n\n// (node: ProseMirrorNode) → boolean\n// Checks if a given `node` is an empty paragraph\nexport const isEmptyParagraph = node => {\n  return !node || (node.type.name === 'paragraph' && node.nodeSize === 2);\n};\n\n// ($pos: ResolvedPos) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table node closest to a given `$pos`.\n//\n// ```javascript\n// const table = findTableClosestToPos(state.doc.resolve(10));\n// ```\nexport const findTableClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\nexport const createCell = (cellType, cellContent = null) => {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n\n  return cellType.createAndFill();\n};\n\n// (rect: {left: number, right: number, top: number, bottom: number}) → (selection: Selection) → boolean\n// Checks if a given CellSelection rect is selected\nexport const isRectSelected = rect => selection => {\n  const map = TableMap.get(selection.$anchorCell.node(-1));\n  const start = selection.$anchorCell.start(-1);\n  const cells = map.cellsInRect(rect);\n  const selectedCells = map.cellsInRect(\n    map.rectBetween(\n      selection.$anchorCell.pos - start,\n      selection.$headCell.pos - start\n    )\n  );\n\n  for (let i = 0, count = cells.length; i < count; i++) {\n    if (selectedCells.indexOf(cells[i]) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// This function transposes an array of array flipping the columns for rows,\n// transposition is a familiar algebra concept;\n// you can get more details here:\n// https://en.wikipedia.org/wiki/Transpose\n//\n// ```javascript\n//\n//  const arr = [\n//    ['a1', 'a2', 'a3'],\n//    ['b1', 'b2', 'b3'],\n//    ['c1', 'c2', 'c3'],\n//    ['d1', 'd2', 'd3'],\n//  ];\n//\n//  const result = transpose(arr);\n//\n//  result === [\n//    ['a1', 'b1', 'c1', 'd1'],\n//    ['a2', 'b2', 'c2', 'd2'],\n//    ['a3', 'b3', 'c3', 'd3'],\n//  ]\n// ```\nexport const transpose = array => {\n  return array[0].map((_, i) => {\n    return array.map(column => column[i]);\n  });\n};\n\n// :: (tableNode: Node) -> Array<Node>\n// This function will transform the table node\n// into a matrix of rows and columns respecting merged cells,\n// for example this table will be convert to the below:\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\nexport const convertTableNodeToArrayOfRows = tableNode => {\n  const map = TableMap.get(tableNode);\n  const rows = [];\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells = [];\n    const seen = {};\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n      const cell = tableNode.nodeAt(cellPos);\n      const rect = map.findCell(cellPos);\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null);\n        continue;\n      }\n      seen[cellPos] = true;\n\n      rowCells.push(cell);\n    }\n\n    rows.push(rowCells);\n  }\n\n  return rows;\n};\n\n// :: (tableNode: Node, tableArray: Array<Node>) -> Node\n// This function will transform a matrix of nodes\n// into table node respecting merged cells and rows configurations,\n// for example this array will be convert to the table below:\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\nexport const convertArrayOfRowsToTableNode = (tableNode, arrayOfNodes) => {\n  const rowsPM = [];\n  const map = TableMap.get(tableNode);\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex);\n    const rowCells = [];\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex][colIndex]) {\n        continue;\n      }\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n\n      const cell = arrayOfNodes[rowIndex][colIndex];\n      const oldCell = tableNode.nodeAt(cellPos);\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks\n      );\n      rowCells.push(newCell);\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks\n  );\n\n  return newTable;\n};\n\nexport const moveTableColumn = (\n  table,\n  indexesOrigin,\n  indexesTarget,\n  direction\n) => {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node));\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nexport const moveTableRow = (\n  table,\n  indexesOrigin,\n  indexesTarget,\n  direction\n) => {\n  let rows = convertTableNodeToArrayOfRows(table.node);\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nconst moveRowInArrayOfRows = (\n  rows,\n  indexesOrigin,\n  indexesTarget,\n  directionOverride\n) => {\n  let direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n\n  const rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  let target;\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]\n        : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n\n  rows.splice.apply(rows, [target, 0].concat(rowsExtracted));\n  return rows;\n};\n\nexport const checkInvalidMovements = (\n  originIndex,\n  targetIndex,\n  targets,\n  type\n) => {\n  const direction = originIndex > targetIndex ? -1 : 1;\n  const errorMessage = `Target position is invalid, you can't move the ${type} ${originIndex} to ${targetIndex}, the target can't be split. You could use tryToFit option.`;\n\n  if (direction === 1) {\n    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (targets.slice(1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  }\n\n  return true;\n};\n","import { Selection } from 'prosemirror-state';\nimport { equalNodeType, isNodeSelection } from './helpers';\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\nexport const findParentNode = predicate => ({ $from }) =>\n  findParentNodeClosestToPos($from, predicate);\n\n// :: ($pos: ResolvedPos, predicate: (node: ProseMirrorNode) → boolean) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\nexport const findParentNodeClosestToPos = ($pos, predicate) => {\n  for (let i = $pos.depth; i > 0; i--) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\nexport const findParentDomRef = (predicate, domAtPos) => selection => {\n  const parent = findParentNode(predicate)(selection);\n  if (parent) {\n    return findDomRefAtPos(parent.pos, domAtPos);\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → boolean\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNode = predicate => selection => {\n  return !!findParentNode(predicate)(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\nexport const findParentNodeOfType = nodeType => selection => {\n  return findParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: ($pos: ResolvedPos, nodeType: union<NodeType, [NodeType]>) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\nexport const findParentNodeOfTypeClosestToPos = ($pos, nodeType) => {\n  return findParentNodeClosestToPos($pos, node =>\n    equalNodeType(nodeType, node)\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → boolean\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNodeOfType = nodeType => selection => {\n  return hasParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\nexport const findParentDomRefOfType = (nodeType, domAtPos) => selection => {\n  return findParentDomRef(node => equalNodeType(nodeType, node), domAtPos)(\n    selection\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Returns a node of a given `nodeType` if it is selected. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\nexport const findSelectedNodeOfType = nodeType => selection => {\n  if (isNodeSelection(selection)) {\n    const { node, $from } = selection;\n    if (equalNodeType(nodeType, node)) {\n      return { node, pos: $from.pos, depth: $from.depth };\n    }\n  }\n};\n\n// :: (selection: Selection) → ?number\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\nexport const findPositionOfNodeBefore = selection => {\n  const { nodeBefore } = selection.$from;\n  const maybeSelection = Selection.findFrom(selection.$from, -1);\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n    if (parent) {\n      return parent.pos;\n    }\n    return maybeSelection.$from.pos;\n  }\n};\n\n// :: (position: number, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → dom.Node\n// Returns DOM reference of a node at a given `position`. If the node type is of type `TEXT_NODE` it will return the reference of the parent node.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\nexport const findDomRefAtPos = (position, domAtPos) => {\n  const dom = domAtPos(position);\n  const node = dom.node.childNodes[dom.offset];\n\n  if (dom.node.nodeType === Node.TEXT_NODE) {\n    return dom.node.parentNode;\n  }\n\n  if (!node || node.nodeType === Node.TEXT_NODE) {\n    return dom.node;\n  }\n\n  return node;\n};\n","// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\nexport const flatten = (node, descend = true) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result = [];\n  node.descendants((child, pos) => {\n    result.push({ node: child, pos });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n};\n\n// :: (node: ProseMirrorNode, predicate: (node: ProseMirrorNode) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\nexport const findChildren = (node, predicate, descend) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter(child => predicate(child.node));\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\nexport const findTextNodes = (node, descend) => {\n  return findChildren(node, child => child.isText, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\nexport const findInlineNodes = (node, descend) => {\n  return findChildren(node, child => child.isInline, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\nexport const findBlockNodes = (node, descend) => {\n  return findChildren(node, child => child.isBlock, descend);\n};\n\n// :: (node: ProseMirrorNode, predicate: (attrs: ?Object) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\nexport const findChildrenByAttr = (node, predicate, descend) => {\n  return findChildren(node, child => !!predicate(child.attrs), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\nexport const findChildrenByType = (node, nodeType, descend) => {\n  return findChildren(node, child => child.type === nodeType, descend);\n};\n\n// :: (node: ProseMirrorNode, markType: markType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\nexport const findChildrenByMark = (node, markType, descend) => {\n  return findChildren(node, child => markType.isInSet(child.marks), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType) → boolean\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\nexport const contains = (node, nodeType) => {\n  return !!findChildrenByType(node, nodeType).length;\n};\n","import {\n  CellSelection,\n  TableMap,\n  addColumn,\n  addRow,\n  removeColumn,\n  removeRow\n} from 'prosemirror-tables';\nimport { Selection } from 'prosemirror-state';\nimport { findParentNode, findParentNodeClosestToPos } from './selection';\nimport { setTextSelection, safeInsert } from './transforms';\nimport {\n  cloneTr,\n  tableNodeTypes,\n  findTableClosestToPos,\n  createCell,\n  isRectSelected,\n  moveTableRow,\n  moveTableColumn,\n  checkInvalidMovements\n} from './helpers';\n\n// :: (selection: Selection) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest table node.\n//\n// ```javascript\n// const table = findTable(selection);\n// ```\nexport const findTable = selection =>\n  findParentNode(\n    node => node.type.spec.tableRole && node.type.spec.tableRole === 'table'\n  )(selection);\n\n// :: (selection: Selection) → boolean\n// Checks if current selection is a `CellSelection`.\n//\n// ```javascript\n// if (isCellSelection(selection)) {\n//   // ...\n// }\n// ```\nexport const isCellSelection = selection => {\n  return selection instanceof CellSelection;\n};\n\n// :: (selection: Selection) → ?{left: number, right: number, top: number, bottom: number}\n// Get the selection rectangle. Returns `undefined` if selection is not a CellSelection.\n//\n// ```javascript\n// const rect = getSelectionRect(selection);\n// ```\nexport const getSelectionRect = selection => {\n  if (!isCellSelection(selection)) {\n    return;\n  }\n  const start = selection.$anchorCell.start(-1);\n  const map = TableMap.get(selection.$anchorCell.node(-1));\n  return map.rectBetween(\n    selection.$anchorCell.pos - start,\n    selection.$headCell.pos - start\n  );\n};\n\n// :: (columnIndex: number) → (selection: Selection) → boolean\n// Checks if entire column at index `columnIndex` is selected.\n//\n// ```javascript\n// const className = isColumnSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isColumnSelected = columnIndex => selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: columnIndex,\n      right: columnIndex + 1,\n      top: 0,\n      bottom: map.height\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (rowIndex: number) → (selection: Selection) → boolean\n// Checks if entire row at index `rowIndex` is selected.\n//\n// ```javascript\n// const className = isRowSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isRowSelected = rowIndex => selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: 0,\n      right: map.width,\n      top: rowIndex,\n      bottom: rowIndex + 1\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (selection: Selection) → boolean\n// Checks if entire table is selected\n//\n// ```javascript\n// const className = isTableSelected(selection) ? 'selected' : '';\n// ```\nexport const isTableSelected = selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (columnIndex: union<number, [number]>) → (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a column(s), where `columnIndex` could be a column index or an array of column indexes.\n//\n// ```javascript\n// const cells = getCellsInColumn(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInColumn = columnIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const indexes = Array.isArray(columnIndex)\n      ? columnIndex\n      : Array.from([columnIndex]);\n    return indexes.reduce((acc, index) => {\n      if (index >= 0 && index <= map.width - 1) {\n        const cells = map.cellsInRect({\n          left: index,\n          right: index + 1,\n          top: 0,\n          bottom: map.height\n        });\n        return acc.concat(\n          cells.map(nodePos => {\n            const node = table.node.nodeAt(nodePos);\n            const pos = nodePos + table.start;\n            return { pos, start: pos + 1, node };\n          })\n        );\n      }\n    }, []);\n  }\n};\n\n// :: (rowIndex: union<number, [number]>) → (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a row(s), where `rowIndex` could be a row index or an array of row indexes.\n//\n// ```javascript\n// const cells = getCellsInRow(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInRow = rowIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const indexes = Array.isArray(rowIndex) ? rowIndex : Array.from([rowIndex]);\n    return indexes.reduce((acc, index) => {\n      if (index >= 0 && index <= map.height - 1) {\n        const cells = map.cellsInRect({\n          left: 0,\n          right: map.width,\n          top: index,\n          bottom: index + 1\n        });\n        return acc.concat(\n          cells.map(nodePos => {\n            const node = table.node.nodeAt(nodePos);\n            const pos = nodePos + table.start;\n            return { pos, start: pos + 1, node };\n          })\n        );\n      }\n    }, []);\n  }\n};\n\n// :: (selection: Selection) → ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of all cells in a table.\n//\n// ```javascript\n// const cells = getCellsInTable(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInTable = selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const cells = map.cellsInRect({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    });\n    return cells.map(nodePos => {\n      const node = table.node.nodeAt(nodePos);\n      const pos = nodePos + table.start;\n      return { pos, start: pos + 1, node };\n    });\n  }\n};\n\nconst select = type => (index, expand) => tr => {\n  const table = findTable(tr.selection);\n  const isRowSelection = type === 'row';\n  if (table) {\n    const map = TableMap.get(table.node);\n\n    // Check if the index is valid\n    if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n      let left = isRowSelection ? 0 : index;\n      let top = isRowSelection ? index : 0;\n      let right = isRowSelection ? map.width : index + 1;\n      let bottom = isRowSelection ? index + 1 : map.height;\n\n      if (expand) {\n        const cell = findCellClosestToPos(tr.selection.$from);\n        if (!cell) {\n          return tr;\n        }\n\n        const selRect = map.findCell(cell.pos - table.start);\n        if (isRowSelection) {\n          top = Math.min(top, selRect.top);\n          bottom = Math.max(bottom, selRect.bottom);\n        } else {\n          left = Math.min(left, selRect.left);\n          right = Math.max(right, selRect.right);\n        }\n      }\n\n      const cellsInFirstRow = map.cellsInRect({\n        left,\n        top,\n        right: isRowSelection ? right : left + 1,\n        bottom: isRowSelection ? top + 1 : bottom\n      });\n\n      const cellsInLastRow =\n        bottom - top === 1\n          ? cellsInFirstRow\n          : map.cellsInRect({\n              left: isRowSelection ? left : right - 1,\n              top: isRowSelection ? bottom - 1 : top,\n              right,\n              bottom\n            });\n\n      const head = table.start + cellsInFirstRow[0];\n      const anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];\n      const $head = tr.doc.resolve(head);\n      const $anchor = tr.doc.resolve(anchor);\n\n      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number, expand: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `columnIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectColumn(i)(state.tr)\n// );\n// ```\nexport const selectColumn = select('column');\n\n// :: (rowIndex: number, expand: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `rowIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectRow(i)(state.tr)\n// );\n// ```\nexport const selectRow = select('row');\n\n// :: (selection: Selection) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on the entire table.\n//\n// ```javascript\n// dispatch(\n//   selectTable(i)(state.tr)\n// );\n// ```\nexport const selectTable = tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const { map } = TableMap.get(table.node);\n    if (map && map.length) {\n      const head = table.start + map[0];\n      const anchor = table.start + map[map.length - 1];\n      const $head = tr.doc.resolve(head);\n      const $anchor = tr.doc.resolve(anchor);\n\n      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n    }\n  }\n  return tr;\n};\n\n// :: (cell: {pos: number, node: ProseMirrorNode}, schema: Schema) → (tr: Transaction) → Transaction\n// Returns a new transaction that clears the content of a given `cell`.\n//\n// ```javascript\n// const $pos = state.doc.resolve(13);\n// dispatch(\n//   emptyCell(findCellClosestToPos($pos), state.schema)(state.tr)\n// );\n// ```\nexport const emptyCell = (cell, schema) => tr => {\n  if (cell) {\n    const { content } = tableNodeTypes(schema).cell.createAndFill();\n    if (!cell.node.content.eq(content)) {\n      tr.replaceWith(cell.pos + 1, cell.pos + cell.node.nodeSize, content);\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new column at index `columnIndex`.\n//\n// ```javascript\n// dispatch(\n//   addColumnAt(i)(state.tr)\n// );\n// ```\nexport const addColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex >= 0 && columnIndex <= map.width) {\n      return cloneTr(\n        addColumn(\n          tr,\n          {\n            map,\n            tableStart: table.start,\n            table: table.node\n          },\n          columnIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (originRowIndex: number, targetRowIndex: targetColumnIndex, options?: MovementOptions) → (tr: Transaction) → Transaction\n// Returns a new transaction that moves the origin row to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a row to a place\n// where we will need to split a row with merged cells it'll throw an exception, for example:\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n// ```\n//\n// if you try to move the row 0 to the row index 1 with tryToFit false,\n// it'll throw an exception since you can't split the row 1;\n// but if \"tryToFit\" is true, it'll move the row using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `bottom-to-top`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveRow(0, 1, { tryToFit: true })`\n// the result will be:\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// since we could put the row zero on index one,\n// we pushed to the best place to fit the row index 0,\n// in this case, row index 2.\n//\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//\n// If you try to move the row 0 to row index 4 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged rows,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n//  1: Always put the origin after the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveRow(x, y, options)(state.tr)\n// );\n// ```\nexport const moveRow = (originRowIndex, targetRowIndex, opts) => tr => {\n  const defaultOptions = { tryToFit: false, direction: 0 };\n  const options = Object.assign(defaultOptions, opts);\n  const table = findTable(tr.selection);\n  if (!table) {\n    return tr;\n  }\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(originRowIndex)(\n    tr\n  );\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(targetRowIndex)(\n    tr\n  );\n\n  if (indexesOriginRow.indexOf(targetRowIndex) > -1) {\n    return tr;\n  }\n\n  if (!options.tryToFit && indexesTargetRow.length > 1) {\n    checkInvalidMovements(\n      originRowIndex,\n      targetRowIndex,\n      indexesTargetRow,\n      'row'\n    );\n  }\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    options.direction\n  );\n\n  return cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  );\n};\n\n// :: (originColumnIndex: number, targetColumnIndex: targetColumnIndex, options?: MovementOptions) → (tr: Transaction) → Transaction\n// Returns a new transaction that moves the origin column to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a column to a place\n// where we will need to split a column with merged cells it'll throw an exception, for example:\n//\n// ```\n//    0      1         2\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// if you try to move the column 0 to the column index 1 with tryToFit false,\n// it'll throw an exception since you can't split the column 1;\n// but if \"tryToFit\" is true, it'll move the column using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `right-to-left`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveColumn(0, 1, { tryToFit: true })`\n// the result will be:\n//\n// ```\n//    0       1             2\n// _____________________ _______\n// |      |             |      |\n// |  B1  |     C1      |  A1  |\n// |______|______ ______|______|\n// |             |      |      |\n// |     B2      |      |  A2  |\n// |______ ______|      |______|\n// |      |      |  D1  |      |\n// |  B3  |  C2  |      |  A3  |\n// |______|______|______|______|\n// ```\n//\n// since we could put the column zero on index one,\n// we pushed to the best place to fit the column 0, in this case, column index 2.\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |      |             |      |             |\n//  |  A1  |  B1  |     C1      |  E1  |     F1      |\n//  |______|______|______ ______|______|______ ______|\n//  |      |             |      |             |      |\n//  |  A2  |     B2      |      |     E2      |      |\n//  |______|______ ______|      |______ ______|      |\n//  |      |      |      |  D1  |      |      |  G2  |\n//  |  A3  |  B3  |  C3  |      |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//\n// If you try to move the column 0 to column index 5 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged columns,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |      |             |\n//  |  B1  |     C1      |  A1  |  E1  |     F1      |\n//  |______|______ ______|______|______|______ ______|\n//  |             |      |      |             |      |\n//  |     B2      |      |  A2  |     E2      |      |\n//  |______ ______|      |______|______ ______|      |\n//  |      |      |  D1  |      |      |      |  G2  |\n//  |  B3  |  C3  |      |  A3  |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  1: Always put the origin after the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveColumn(x, y, options)(state.tr)\n// );\n// ```\nexport const moveColumn = (\n  originColumnIndex,\n  targetColumnIndex,\n  opts\n) => tr => {\n  const defaultOptions = { tryToFit: false, direction: 0 };\n  const options = Object.assign(defaultOptions, opts);\n  const table = findTable(tr.selection);\n  if (!table) {\n    return tr;\n  }\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(\n    originColumnIndex\n  )(tr);\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(\n    targetColumnIndex\n  )(tr);\n\n  if (indexesOriginColumn.indexOf(targetColumnIndex) > -1) {\n    return tr;\n  }\n\n  if (!options.tryToFit && indexesTargetColumn.length > 1) {\n    checkInvalidMovements(\n      originColumnIndex,\n      targetColumnIndex,\n      indexesTargetColumn,\n      'column'\n    );\n  }\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    options.direction\n  );\n\n  return cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  );\n};\n\n// :: (rowIndex: number, clonePreviousRow?: boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new row at index `rowIndex`. Optionally clone the previous row.\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i)(state.tr)\n// );\n// ```\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i, true)(state.tr)\n// );\n// ```\nexport const addRowAt = (rowIndex, clonePreviousRow) => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const cloneRowIndex = rowIndex - 1;\n\n    if (clonePreviousRow && cloneRowIndex >= 0) {\n      return cloneTr(cloneRowAt(cloneRowIndex)(tr));\n    }\n\n    if (rowIndex >= 0 && rowIndex <= map.height) {\n      return cloneTr(\n        addRow(\n          tr,\n          {\n            map,\n            tableStart: table.start,\n            table: table.node\n          },\n          rowIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (cloneRowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new row after `cloneRowIndex`, cloning the row attributes at `cloneRowIndex`.\n//\n// ```javascript\n// dispatch(\n//   cloneRowAt(i)(state.tr)\n// );\n// ```\nexport const cloneRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n\n    if (rowIndex >= 0 && rowIndex <= map.height) {\n      const tableNode = table.node;\n      const tableNodes = tableNodeTypes(tableNode.type.schema);\n\n      let rowPos = table.start;\n      for (let i = 0; i < rowIndex + 1; i++) {\n        rowPos += tableNode.child(i).nodeSize;\n      }\n\n      const cloneRow = tableNode.child(rowIndex);\n      // Re-create the same nodes with same attrs, dropping the node content.\n      let cells = [];\n      let rowWidth = 0;\n      cloneRow.forEach(cell => {\n        // If we're copying a row with rowspan somewhere, we dont want to copy that cell\n        // We'll increment its span below.\n        if (cell.attrs.rowspan === 1) {\n          rowWidth += cell.attrs.colspan;\n          cells.push(\n            tableNodes[cell.type.spec.tableRole].createAndFill(\n              cell.attrs,\n              cell.marks\n            )\n          );\n        }\n      });\n\n      // If a higher row spans past our clone row, bump the higher row to cover this new row too.\n      if (rowWidth < map.width) {\n        let rowSpanCells = [];\n        for (let i = rowIndex; i >= 0; i--) {\n          let foundCells = filterCellsInRow(i, (cell, tr) => {\n            const rowspan = cell.node.attrs.rowspan;\n            const spanRange = i + rowspan;\n            return rowspan > 1 && spanRange > rowIndex;\n          })(tr);\n          rowSpanCells.push(...foundCells);\n        }\n\n        if (rowSpanCells.length) {\n          rowSpanCells.forEach(cell => {\n            tr = setCellAttrs(cell, {\n              rowspan: cell.node.attrs.rowspan + 1\n            })(tr);\n          });\n        }\n      }\n\n      return safeInsert(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(\n        tr\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeColumnAt(i)(state.tr)\n// );\n// ```\nexport const removeColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex === 0 && map.width === 1) {\n      return removeTable(tr);\n    } else if (columnIndex >= 0 && columnIndex <= map.width) {\n      removeColumn(\n        tr,\n        {\n          map,\n          tableStart: table.start,\n          table: table.node\n        },\n        columnIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (rowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeRowAt(i)(state.tr)\n// );\n// ```\nexport const removeRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (rowIndex === 0 && map.height === 1) {\n      return removeTable(tr);\n    } else if (rowIndex >= 0 && rowIndex <= map.height) {\n      removeRow(\n        tr,\n        {\n          map,\n          tableStart: table.start,\n          table: table.node\n        },\n        rowIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes a table node if the cursor is inside of it.\n//\n// ```javascript\n// dispatch(\n//   removeTable(state.tr)\n// );\n// ```\nexport const removeTable = tr => {\n  const { $from } = tr.selection;\n  for (let depth = $from.depth; depth > 0; depth--) {\n    let node = $from.node(depth);\n    if (node.type.spec.tableRole === 'table') {\n      return cloneTr(tr.delete($from.before(depth), $from.after(depth)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected columns.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedColumns(state.tr)\n// );\n// ```\nexport const removeSelectedColumns = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.start,\n        selection.$headCell.pos - table.start\n      );\n\n      if (rect.left == 0 && rect.right == map.width) {\n        return false;\n      }\n\n      const pmTableRect = Object.assign({}, rect, {\n        map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (let i = pmTableRect.right - 1; ; i--) {\n        removeColumn(tr, pmTableRect, i);\n        if (i === pmTableRect.left) {\n          break;\n        }\n        pmTableRect.table = pmTableRect.tableStart\n          ? tr.doc.nodeAt(pmTableRect.tableStart - 1)\n          : tr.doc;\n        pmTableRect.map = TableMap.get(pmTableRect.table);\n      }\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected rows.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedRows(state.tr)\n// );\n// ```\nexport const removeSelectedRows = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.start,\n        selection.$headCell.pos - table.start\n      );\n\n      if (rect.top == 0 && rect.bottom == map.height) {\n        return false;\n      }\n\n      const pmTableRect = Object.assign({}, rect, {\n        map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (let i = pmTableRect.bottom - 1; ; i--) {\n        removeRow(tr, pmTableRect, i);\n        if (i === pmTableRect.top) {\n          break;\n        }\n        pmTableRect.table = pmTableRect.tableStart\n          ? tr.doc.nodeAt(pmTableRect.tableStart - 1)\n          : tr.doc;\n        pmTableRect.map = TableMap.get(pmTableRect.table);\n      }\n\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeColumnClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeColumnClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeRowClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeRowClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));\n  }\n  return tr;\n};\n\n// :: (columnIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) → Transaction, setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a column at a given `columnIndex`.\n// It will set the selection into the last cell of the column if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInColumn(0, (cell, tr) => emptyCell(cell, state.schema)(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInColumn = (\n  columnIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInColumn(columnIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n      tr.setSelection(Selection.near($pos));\n    }\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// :: (rowIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) → Transaction, setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a row at a given `rowIndex`.\n// It will set the selection into the last cell of the row if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInRow(0, (cell, tr) => setCellAttrs(cell, { background: 'red' })(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInRow = (\n  rowIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n      tr.setSelection(Selection.near($pos));\n    }\n  }\n  return tr;\n};\n\n// :: (cell: {pos: number, start: number, node: ProseMirrorNode}, attrs: Object) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets given `attrs` to a given `cell`.\n//\n// ```javascript\n// dispatch(\n//   setCellAttrs(findCellClosestToPos($pos), { background: 'blue' })(tr);\n// );\n// ```\nexport const setCellAttrs = (cell, attrs) => tr => {\n  if (cell) {\n    tr.setNodeMarkup(cell.pos, null, Object.assign({}, cell.node.attrs, attrs));\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// :: (schema: Schema, rowsCount: ?number, colsCount: ?number, withHeaderRow: ?boolean, cellContent: ?Node) → Node\n// Returns a table node of a given size.\n// `withHeaderRow` defines whether the first row of the table will be a header row.\n// `cellContent` defines the content of each cell.\n//\n// ```javascript\n// const table = createTable(state.schema); // 3x3 table node\n// dispatch(\n//   tr.replaceSelectionWith(table).scrollIntoView()\n// );\n// ```\nexport const createTable = (\n  schema,\n  rowsCount = 3,\n  colsCount = 3,\n  withHeaderRow = true,\n  cellContent = null\n) => {\n  const {\n    cell: tableCell,\n    header_cell: tableHeader,\n    row: tableRow,\n    table\n  } = tableNodeTypes(schema);\n\n  const cells = [];\n  const headerCells = [];\n  for (let i = 0; i < colsCount; i++) {\n    cells.push(createCell(tableCell, cellContent));\n\n    if (withHeaderRow) {\n      headerCells.push(createCell(tableHeader, cellContent));\n    }\n  }\n\n  const rows = [];\n  for (let i = 0; i < rowsCount; i++) {\n    rows.push(\n      tableRow.createChecked(\n        null,\n        withHeaderRow && i === 0 ? headerCells : cells\n      )\n    );\n  }\n\n  return table.createChecked(null, rows);\n};\n\n// :: ($pos: ResolvedPos) → ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table cell or a table header node closest to a given `$pos`.\n//\n// ```javascript\n// const cell = findCellClosestToPos(state.selection.$from);\n// ```\nexport const findCellClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\n// :: ($pos: ResolvedPos) → ?{left: number, top: number, right: number, bottom: number}\n// Returns the rectangle spanning a cell closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   findCellRectClosestToPos(state.selection.$from)\n// );\n// ```\nexport const findCellRectClosestToPos = $pos => {\n  const cell = findCellClosestToPos($pos);\n  if (cell) {\n    const table = findTableClosestToPos($pos);\n    const map = TableMap.get(table.node);\n    const cellPos = cell.pos - table.start;\n    return map.rectBetween(cellPos, cellPos);\n  }\n};\n\nconst filterCellsInRow = (rowIndex, predicate) => tr => {\n  let foundCells = [];\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    for (let j = cells.length - 1; j >= 0; j--) {\n      if (predicate(cells[j], tr)) {\n        foundCells.push(cells[j]);\n      }\n    }\n  }\n\n  return foundCells;\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a column at index `columnIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInColumn(3)(state.tr);\n// ```\nexport const getSelectionRangeInColumn = columnIndex => tr => {\n  let startIndex = columnIndex;\n  let endIndex = columnIndex;\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInColumn(i)(tr.selection);\n    if (cells) {\n      cells.forEach(cell => {\n        let maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInColumn(i)(tr.selection);\n    if (cells) {\n      cells.forEach(cell => {\n        let maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInColumn(i)(tr.selection);\n    if (maybeCells && maybeCells.length) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedColumnCells = getCellsInColumn(startIndex)(tr.selection);\n  const firstRowCells = getCellsInRow(0)(tr.selection);\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInColumn(i)(tr.selection);\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j].pos === columnCells[0].pos) {\n          headCell = columnCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n};\n\n// :: (rowIndex: number) → (tr: Transaction) → {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a row at index `rowIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInRow(3)(state.tr);\n// ```\nexport const getSelectionRangeInRow = rowIndex => tr => {\n  let startIndex = rowIndex;\n  let endIndex = rowIndex;\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i)(tr.selection);\n    cells.forEach(cell => {\n      let maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n      if (maybeEndIndex >= startIndex) {\n        startIndex = i;\n      }\n      if (maybeEndIndex > endIndex) {\n        endIndex = maybeEndIndex;\n      }\n    });\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i)(tr.selection);\n    cells.forEach(cell => {\n      let maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n        endIndex = maybeEndIndex;\n      }\n    });\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i)(tr.selection);\n    if (maybeCells && maybeCells.length) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedRowCells = getCellsInRow(startIndex)(tr.selection);\n  const firstColumnCells = getCellsInColumn(0)(tr.selection);\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1].pos\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i)(tr.selection);\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j].pos === rowCells[0].pos) {\n          headCell = rowCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n};\n"]},"metadata":{},"sourceType":"script"}