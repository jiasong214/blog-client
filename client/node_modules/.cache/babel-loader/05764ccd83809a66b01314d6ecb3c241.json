{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst token_1 = __importDefault(require(\"markdown-it/lib/token\"));\n\nfunction isParagraph(token) {\n  return token.type === \"paragraph_open\";\n}\n\nfunction isInline(token) {\n  return token.type === \"inline\" && token.level === 1;\n}\n\nfunction isLinkOpen(token) {\n  return token.type === \"link_open\";\n}\n\nfunction isLinkClose(token) {\n  return token.type === \"link_close\";\n}\n\nfunction default_1(embeds) {\n  function isEmbed(token, link) {\n    const href = link.attrs ? link.attrs[0][1] : \"\";\n    const simpleLink = href === token.content;\n    if (!simpleLink) return false;\n    if (!embeds) return false;\n\n    for (const embed of embeds) {\n      const matches = embed.matcher(href);\n\n      if (matches) {\n        return Object.assign(Object.assign({}, embed), {\n          matches\n        });\n      }\n    }\n  }\n\n  return function markdownEmbeds(md) {\n    md.core.ruler.after(\"inline\", \"embeds\", state => {\n      const tokens = state.tokens;\n      let insideLink;\n\n      for (let i = 0; i < tokens.length - 1; i++) {\n        if (isInline(tokens[i]) && isParagraph(tokens[i - 1])) {\n          const tokenChildren = tokens[i].children || [];\n\n          for (let j = 0; j < tokenChildren.length - 1; j++) {\n            const current = tokenChildren[j];\n            if (!current) continue;\n\n            if (isLinkOpen(current)) {\n              insideLink = current;\n              continue;\n            }\n\n            if (isLinkClose(current)) {\n              insideLink = null;\n              continue;\n            }\n\n            if (insideLink) {\n              const result = isEmbed(current, insideLink);\n\n              if (result) {\n                const {\n                  content\n                } = current;\n                const token = new token_1.default(\"embed\", \"iframe\", 0);\n                token.attrSet(\"href\", content);\n                token.attrSet(\"matches\", result.matches);\n                tokens.splice(i - 1, 3, token);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    });\n  };\n}\n\nexports.default = default_1;","map":{"version":3,"sources":["../../../src/lib/markdown/embeds.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst token_1 = __importDefault(require(\"markdown-it/lib/token\"));\nfunction isParagraph(token) {\n    return token.type === \"paragraph_open\";\n}\nfunction isInline(token) {\n    return token.type === \"inline\" && token.level === 1;\n}\nfunction isLinkOpen(token) {\n    return token.type === \"link_open\";\n}\nfunction isLinkClose(token) {\n    return token.type === \"link_close\";\n}\nfunction default_1(embeds) {\n    function isEmbed(token, link) {\n        const href = link.attrs ? link.attrs[0][1] : \"\";\n        const simpleLink = href === token.content;\n        if (!simpleLink)\n            return false;\n        if (!embeds)\n            return false;\n        for (const embed of embeds) {\n            const matches = embed.matcher(href);\n            if (matches) {\n                return Object.assign(Object.assign({}, embed), { matches });\n            }\n        }\n    }\n    return function markdownEmbeds(md) {\n        md.core.ruler.after(\"inline\", \"embeds\", state => {\n            const tokens = state.tokens;\n            let insideLink;\n            for (let i = 0; i < tokens.length - 1; i++) {\n                if (isInline(tokens[i]) && isParagraph(tokens[i - 1])) {\n                    const tokenChildren = tokens[i].children || [];\n                    for (let j = 0; j < tokenChildren.length - 1; j++) {\n                        const current = tokenChildren[j];\n                        if (!current)\n                            continue;\n                        if (isLinkOpen(current)) {\n                            insideLink = current;\n                            continue;\n                        }\n                        if (isLinkClose(current)) {\n                            insideLink = null;\n                            continue;\n                        }\n                        if (insideLink) {\n                            const result = isEmbed(current, insideLink);\n                            if (result) {\n                                const { content } = current;\n                                const token = new token_1.default(\"embed\", \"iframe\", 0);\n                                token.attrSet(\"href\", content);\n                                token.attrSet(\"matches\", result.matches);\n                                tokens.splice(i - 1, 3, token);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        });\n    };\n}\nexports.default = default_1;\n//# sourceMappingURL=embeds.js.map"]},"metadata":{},"sourceType":"script"}