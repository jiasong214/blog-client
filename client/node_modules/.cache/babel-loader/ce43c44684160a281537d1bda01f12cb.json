{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction default_1(options) {\n  const delimCharCode = options.delim.charCodeAt(0);\n  return function emphasisPlugin(md) {\n    function tokenize(state, silent) {\n      let i, token;\n      const start = state.pos,\n            marker = state.src.charCodeAt(start);\n\n      if (silent) {\n        return false;\n      }\n\n      if (marker !== delimCharCode) {\n        return false;\n      }\n\n      const scanned = state.scanDelims(state.pos, true);\n      const ch = String.fromCharCode(marker);\n      let len = scanned.length;\n\n      if (len < 2) {\n        return false;\n      }\n\n      if (len % 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch;\n        len--;\n      }\n\n      for (i = 0; i < len; i += 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch + ch;\n\n        if (!scanned.can_open && !scanned.can_close) {\n          continue;\n        }\n\n        state.delimiters.push({\n          marker,\n          length: 0,\n          jump: i,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close\n        });\n      }\n\n      state.pos += scanned.length;\n      return true;\n    }\n\n    function postProcess(state, delimiters) {\n      let i, j, startDelim, endDelim, token;\n      const loneMarkers = [],\n            max = delimiters.length;\n\n      for (i = 0; i < max; i++) {\n        startDelim = delimiters[i];\n\n        if (startDelim.marker !== delimCharCode) {\n          continue;\n        }\n\n        if (startDelim.end === -1) {\n          continue;\n        }\n\n        endDelim = delimiters[startDelim.end];\n        token = state.tokens[startDelim.token];\n        token.type = `${options.mark}_open`;\n        token.tag = \"span\";\n        token.attrs = [[\"class\", options.mark]];\n        token.nesting = 1;\n        token.markup = options.delim;\n        token.content = \"\";\n        token = state.tokens[endDelim.token];\n        token.type = `${options.mark}_close`;\n        token.tag = \"span\";\n        token.nesting = -1;\n        token.markup = options.delim;\n        token.content = \"\";\n\n        if (state.tokens[endDelim.token - 1].type === \"text\" && state.tokens[endDelim.token - 1].content === options.delim[0]) {\n          loneMarkers.push(endDelim.token - 1);\n        }\n      }\n\n      while (loneMarkers.length) {\n        i = loneMarkers.pop();\n        j = i + 1;\n\n        while (j < state.tokens.length && state.tokens[j].type === `${options.mark}_close`) {\n          j++;\n        }\n\n        j--;\n\n        if (i !== j) {\n          token = state.tokens[j];\n          state.tokens[j] = state.tokens[i];\n          state.tokens[i] = token;\n        }\n      }\n    }\n\n    md.inline.ruler.before(\"emphasis\", options.mark, tokenize);\n    md.inline.ruler2.before(\"emphasis\", options.mark, function (state) {\n      let curr;\n      const tokensMeta = state.tokens_meta,\n            max = (state.tokens_meta || []).length;\n      postProcess(state, state.delimiters);\n\n      for (curr = 0; curr < max; curr++) {\n        if (tokensMeta[curr] && tokensMeta[curr].delimiters) {\n          postProcess(state, tokensMeta[curr].delimiters);\n        }\n      }\n    });\n  };\n}\n\nexports.default = default_1;","map":{"version":3,"sources":["../../../src/lib/markdown/mark.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction default_1(options) {\n    const delimCharCode = options.delim.charCodeAt(0);\n    return function emphasisPlugin(md) {\n        function tokenize(state, silent) {\n            let i, token;\n            const start = state.pos, marker = state.src.charCodeAt(start);\n            if (silent) {\n                return false;\n            }\n            if (marker !== delimCharCode) {\n                return false;\n            }\n            const scanned = state.scanDelims(state.pos, true);\n            const ch = String.fromCharCode(marker);\n            let len = scanned.length;\n            if (len < 2) {\n                return false;\n            }\n            if (len % 2) {\n                token = state.push(\"text\", \"\", 0);\n                token.content = ch;\n                len--;\n            }\n            for (i = 0; i < len; i += 2) {\n                token = state.push(\"text\", \"\", 0);\n                token.content = ch + ch;\n                if (!scanned.can_open && !scanned.can_close) {\n                    continue;\n                }\n                state.delimiters.push({\n                    marker,\n                    length: 0,\n                    jump: i,\n                    token: state.tokens.length - 1,\n                    end: -1,\n                    open: scanned.can_open,\n                    close: scanned.can_close,\n                });\n            }\n            state.pos += scanned.length;\n            return true;\n        }\n        function postProcess(state, delimiters) {\n            let i, j, startDelim, endDelim, token;\n            const loneMarkers = [], max = delimiters.length;\n            for (i = 0; i < max; i++) {\n                startDelim = delimiters[i];\n                if (startDelim.marker !== delimCharCode) {\n                    continue;\n                }\n                if (startDelim.end === -1) {\n                    continue;\n                }\n                endDelim = delimiters[startDelim.end];\n                token = state.tokens[startDelim.token];\n                token.type = `${options.mark}_open`;\n                token.tag = \"span\";\n                token.attrs = [[\"class\", options.mark]];\n                token.nesting = 1;\n                token.markup = options.delim;\n                token.content = \"\";\n                token = state.tokens[endDelim.token];\n                token.type = `${options.mark}_close`;\n                token.tag = \"span\";\n                token.nesting = -1;\n                token.markup = options.delim;\n                token.content = \"\";\n                if (state.tokens[endDelim.token - 1].type === \"text\" &&\n                    state.tokens[endDelim.token - 1].content === options.delim[0]) {\n                    loneMarkers.push(endDelim.token - 1);\n                }\n            }\n            while (loneMarkers.length) {\n                i = loneMarkers.pop();\n                j = i + 1;\n                while (j < state.tokens.length &&\n                    state.tokens[j].type === `${options.mark}_close`) {\n                    j++;\n                }\n                j--;\n                if (i !== j) {\n                    token = state.tokens[j];\n                    state.tokens[j] = state.tokens[i];\n                    state.tokens[i] = token;\n                }\n            }\n        }\n        md.inline.ruler.before(\"emphasis\", options.mark, tokenize);\n        md.inline.ruler2.before(\"emphasis\", options.mark, function (state) {\n            let curr;\n            const tokensMeta = state.tokens_meta, max = (state.tokens_meta || []).length;\n            postProcess(state, state.delimiters);\n            for (curr = 0; curr < max; curr++) {\n                if (tokensMeta[curr] && tokensMeta[curr].delimiters) {\n                    postProcess(state, tokensMeta[curr].delimiters);\n                }\n            }\n        });\n    };\n}\nexports.default = default_1;\n//# sourceMappingURL=mark.js.map"]},"metadata":{},"sourceType":"script"}