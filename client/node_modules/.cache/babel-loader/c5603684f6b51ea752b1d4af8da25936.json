{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\n\nfunction getMarksBetween(start, end, state) {\n  let marks = [];\n  state.doc.nodesBetween(start, end, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      start: pos,\n      end: pos + node.nodeSize,\n      mark\n    }))];\n  });\n  return marks;\n}\n\nfunction default_1(regexp, markType, getAttrs) {\n  return new prosemirror_inputrules_1.InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n    const m = match.length - 1;\n    let markEnd = end;\n    let markStart = start;\n\n    if (match[m]) {\n      const matchStart = start + match[0].indexOf(match[m - 1]);\n      const matchEnd = matchStart + match[m - 1].length - 1;\n      const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n      const textEnd = textStart + match[m].length;\n      const excludedMarks = getMarksBetween(start, end, state).filter(item => item.mark.type.excludes(markType)).filter(item => item.end > matchStart);\n\n      if (excludedMarks.length) {\n        return null;\n      }\n\n      if (textEnd < matchEnd) {\n        tr.delete(textEnd, matchEnd);\n      }\n\n      if (textStart > matchStart) {\n        tr.delete(matchStart, textStart);\n      }\n\n      markStart = matchStart;\n      markEnd = markStart + match[m].length;\n    }\n\n    tr.addMark(markStart, markEnd, markType.create(attrs));\n    tr.removeStoredMark(markType);\n    return tr;\n  });\n}\n\nexports.default = default_1;","map":{"version":3,"sources":["../../src/lib/markInputRule.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,wBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAGA,SAAS,eAAT,CAAyB,KAAzB,EAAwC,GAAxC,EAAqD,KAArD,EAAuE;AACrE,MAAI,KAAK,GAAiD,EAA1D;AAEA,EAAA,KAAK,CAAC,GAAN,CAAU,YAAV,CAAuB,KAAvB,EAA8B,GAA9B,EAAmC,CAAC,IAAD,EAAO,GAAP,KAAc;AAC/C,IAAA,KAAK,GAAG,CACN,GAAG,KADG,EAEN,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,IAAI,KAAK;AACzB,MAAA,KAAK,EAAE,GADkB;AAEzB,MAAA,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,QAFS;AAGzB,MAAA;AAHyB,KAAL,CAAnB,CAFG,CAAR;AAQD,GATD;AAWA,SAAO,KAAP;AACD;;AAED,SAAA,SAAA,CACE,MADF,EAEE,QAFF,EAGE,QAHF,EAG+C;AAE7C,SAAO,IAAI,wBAAA,CAAA,SAAJ,CACL,MADK,EAEL,CAAC,KAAD,EAAqB,KAArB,EAAsC,KAAtC,EAAqD,GAArD,KAAoE;AAClE,UAAM,KAAK,GAAG,QAAQ,YAAY,QAApB,GAA+B,QAAQ,CAAC,KAAD,CAAvC,GAAiD,QAA/D;AACA,UAAM;AAAE,MAAA;AAAF,QAAS,KAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAC,MAAN,GAAe,CAAzB;AACA,QAAI,OAAO,GAAG,GAAd;AACA,QAAI,SAAS,GAAG,KAAhB;;AAEA,QAAI,KAAK,CAAC,CAAD,CAAT,EAAc;AACZ,YAAM,UAAU,GAAG,KAAK,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,OAAT,CAAiB,KAAK,CAAC,CAAC,GAAG,CAAL,CAAtB,CAA3B;AACA,YAAM,QAAQ,GAAG,UAAU,GAAG,KAAK,CAAC,CAAC,GAAG,CAAL,CAAL,CAAa,MAA1B,GAAmC,CAApD;AACA,YAAM,SAAS,GAAG,UAAU,GAAG,KAAK,CAAC,CAAC,GAAG,CAAL,CAAL,CAAa,WAAb,CAAyB,KAAK,CAAC,CAAD,CAA9B,CAA/B;AACA,YAAM,OAAO,GAAG,SAAS,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,MAArC;AAEA,YAAM,aAAa,GAAG,eAAe,CAAC,KAAD,EAAQ,GAAR,EAAa,KAAb,CAAf,CACnB,MADmB,CACZ,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,QAAf,CAAwB,QAAxB,CADI,EAEnB,MAFmB,CAEZ,IAAI,IAAI,IAAI,CAAC,GAAL,GAAW,UAFP,CAAtB;;AAIA,UAAI,aAAa,CAAC,MAAlB,EAA0B;AACxB,eAAO,IAAP;AACD;;AAED,UAAI,OAAO,GAAG,QAAd,EAAwB;AACtB,QAAA,EAAE,CAAC,MAAH,CAAU,OAAV,EAAmB,QAAnB;AACD;;AACD,UAAI,SAAS,GAAG,UAAhB,EAA4B;AAC1B,QAAA,EAAE,CAAC,MAAH,CAAU,UAAV,EAAsB,SAAtB;AACD;;AACD,MAAA,SAAS,GAAG,UAAZ;AACA,MAAA,OAAO,GAAG,SAAS,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,MAA/B;AACD;;AAED,IAAA,EAAE,CAAC,OAAH,CAAW,SAAX,EAAsB,OAAtB,EAA+B,QAAQ,CAAC,MAAT,CAAgB,KAAhB,CAA/B;AACA,IAAA,EAAE,CAAC,gBAAH,CAAoB,QAApB;AACA,WAAO,EAAP;AACD,GApCI,CAAP;AAsCD;;AA3CD,OAAA,CAAA,OAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\nfunction getMarksBetween(start, end, state) {\n    let marks = [];\n    state.doc.nodesBetween(start, end, (node, pos) => {\n        marks = [\n            ...marks,\n            ...node.marks.map(mark => ({\n                start: pos,\n                end: pos + node.nodeSize,\n                mark,\n            })),\n        ];\n    });\n    return marks;\n}\nfunction default_1(regexp, markType, getAttrs) {\n    return new prosemirror_inputrules_1.InputRule(regexp, (state, match, start, end) => {\n        const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        const { tr } = state;\n        const m = match.length - 1;\n        let markEnd = end;\n        let markStart = start;\n        if (match[m]) {\n            const matchStart = start + match[0].indexOf(match[m - 1]);\n            const matchEnd = matchStart + match[m - 1].length - 1;\n            const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n            const textEnd = textStart + match[m].length;\n            const excludedMarks = getMarksBetween(start, end, state)\n                .filter(item => item.mark.type.excludes(markType))\n                .filter(item => item.end > matchStart);\n            if (excludedMarks.length) {\n                return null;\n            }\n            if (textEnd < matchEnd) {\n                tr.delete(textEnd, matchEnd);\n            }\n            if (textStart > matchStart) {\n                tr.delete(matchStart, textStart);\n            }\n            markStart = matchStart;\n            markEnd = markStart + match[m].length;\n        }\n        tr.addMark(markStart, markEnd, markType.create(attrs));\n        tr.removeStoredMark(markType);\n        return tr;\n    });\n}\nexports.default = default_1;\n//# sourceMappingURL=markInputRule.js.map"]},"metadata":{},"sourceType":"script"}