{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isHardbreak(token) {\n  return token.type === \"hardbreak\" || token.type === \"text\" && token.content === \"\\\\\";\n}\n\nfunction markdownBreakToParagraphs(md) {\n  md.core.ruler.after(\"inline\", \"breaks\", state => {\n    const {\n      Token\n    } = state;\n    const tokens = state.tokens;\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      const tokenChildren = tokens[i].children || [];\n      const matches = tokenChildren.filter(isHardbreak);\n\n      if (matches.length) {\n        let token;\n        const nodes = [];\n        const children = tokenChildren.filter(child => !isHardbreak(child));\n        let count = matches.length;\n        if (!!children.length) count++;\n\n        for (let i = 0; i < count; i++) {\n          const isLast = i === count - 1;\n          token = new Token(\"paragraph_open\", \"p\", 1);\n          nodes.push(token);\n          const text = new Token(\"text\", \"\", 0);\n          text.content = \"\";\n          token = new Token(\"inline\", \"\", 0);\n          token.level = 1;\n          token.children = isLast ? [text, ...children] : [text];\n          token.content = \"\";\n          nodes.push(token);\n          token = new Token(\"paragraph_close\", \"p\", -1);\n          nodes.push(token);\n        }\n\n        tokens.splice(i - 1, 3, ...nodes);\n      }\n    }\n\n    return false;\n  });\n}\n\nexports.default = markdownBreakToParagraphs;","map":{"version":3,"sources":["../../../src/lib/markdown/breaks.ts"],"names":[],"mappings":";;;;;;AAGA,SAAS,WAAT,CAAqB,KAArB,EAAiC;AAC/B,SACE,KAAK,CAAC,IAAN,KAAe,WAAf,IACC,KAAK,CAAC,IAAN,KAAe,MAAf,IAAyB,KAAK,CAAC,OAAN,KAAkB,IAF9C;AAID;;AAED,SAAwB,yBAAxB,CAAkD,EAAlD,EAAgE;AAE9D,EAAA,EAAE,CAAC,IAAH,CAAQ,KAAR,CAAc,KAAd,CAAoB,QAApB,EAA8B,QAA9B,EAAwC,KAAK,IAAG;AAC9C,UAAM;AAAE,MAAA;AAAF,QAAY,KAAlB;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,MAArB;;AAGA,SAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAA7B,EAAgC,CAAC,GAAG,CAApC,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,YAAM,aAAa,GAAG,MAAM,CAAC,CAAD,CAAN,CAAU,QAAV,IAAsB,EAA5C;AACA,YAAM,OAAO,GAAG,aAAa,CAAC,MAAd,CAAqB,WAArB,CAAhB;;AAEA,UAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,YAAI,KAAJ;AAEA,cAAM,KAAK,GAAY,EAAvB;AACA,cAAM,QAAQ,GAAG,aAAa,CAAC,MAAd,CAAqB,KAAK,IAAI,CAAC,WAAW,CAAC,KAAD,CAA1C,CAAjB;AAEA,YAAI,KAAK,GAAG,OAAO,CAAC,MAApB;AACA,YAAI,CAAC,CAAC,QAAQ,CAAC,MAAf,EAAuB,KAAK;;AAE5B,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,gBAAM,MAAM,GAAG,CAAC,KAAK,KAAK,GAAG,CAA7B;AAEA,UAAA,KAAK,GAAG,IAAI,KAAJ,CAAU,gBAAV,EAA4B,GAA5B,EAAiC,CAAjC,CAAR;AACA,UAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AAEA,gBAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,MAAV,EAAkB,EAAlB,EAAsB,CAAtB,CAAb;AACA,UAAA,IAAI,CAAC,OAAL,GAAe,EAAf;AAEA,UAAA,KAAK,GAAG,IAAI,KAAJ,CAAU,QAAV,EAAoB,EAApB,EAAwB,CAAxB,CAAR;AACA,UAAA,KAAK,CAAC,KAAN,GAAc,CAAd;AACA,UAAA,KAAK,CAAC,QAAN,GAAiB,MAAM,GAAG,CAAC,IAAD,EAAO,GAAG,QAAV,CAAH,GAAyB,CAAC,IAAD,CAAhD;AACA,UAAA,KAAK,CAAC,OAAN,GAAgB,EAAhB;AACA,UAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AAEA,UAAA,KAAK,GAAG,IAAI,KAAJ,CAAU,iBAAV,EAA6B,GAA7B,EAAkC,CAAC,CAAnC,CAAR;AACA,UAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACD;;AAED,QAAA,MAAM,CAAC,MAAP,CAAc,CAAC,GAAG,CAAlB,EAAqB,CAArB,EAAwB,GAAG,KAA3B;AACD;AACF;;AAED,WAAO,KAAP;AACD,GA1CD;AA2CD;;AA7CD,OAAA,CAAA,OAAA,GAAA,yBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isHardbreak(token) {\n    return (token.type === \"hardbreak\" ||\n        (token.type === \"text\" && token.content === \"\\\\\"));\n}\nfunction markdownBreakToParagraphs(md) {\n    md.core.ruler.after(\"inline\", \"breaks\", state => {\n        const { Token } = state;\n        const tokens = state.tokens;\n        for (let i = tokens.length - 1; i > 0; i--) {\n            const tokenChildren = tokens[i].children || [];\n            const matches = tokenChildren.filter(isHardbreak);\n            if (matches.length) {\n                let token;\n                const nodes = [];\n                const children = tokenChildren.filter(child => !isHardbreak(child));\n                let count = matches.length;\n                if (!!children.length)\n                    count++;\n                for (let i = 0; i < count; i++) {\n                    const isLast = i === count - 1;\n                    token = new Token(\"paragraph_open\", \"p\", 1);\n                    nodes.push(token);\n                    const text = new Token(\"text\", \"\", 0);\n                    text.content = \"\";\n                    token = new Token(\"inline\", \"\", 0);\n                    token.level = 1;\n                    token.children = isLast ? [text, ...children] : [text];\n                    token.content = \"\";\n                    nodes.push(token);\n                    token = new Token(\"paragraph_close\", \"p\", -1);\n                    nodes.push(token);\n                }\n                tokens.splice(i - 1, 3, ...nodes);\n            }\n        }\n        return false;\n    });\n}\nexports.default = markdownBreakToParagraphs;\n//# sourceMappingURL=breaks.js.map"]},"metadata":{},"sourceType":"script"}