{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MarkdownSerializerState = exports.MarkdownSerializer = void 0;\n\nclass MarkdownSerializer {\n  constructor(nodes, marks) {\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n\n  serialize(content, options) {\n    const state = new MarkdownSerializerState(this.nodes, this.marks, options);\n    state.renderContent(content);\n    return state.out;\n  }\n\n}\n\nexports.MarkdownSerializer = MarkdownSerializer;\n\nclass MarkdownSerializerState {\n  constructor(nodes, marks, options) {\n    this.nodes = nodes;\n    this.marks = marks;\n    this.delim = this.out = \"\";\n    this.closed = false;\n    this.inTightList = false;\n    this.options = options || {};\n    if (typeof this.options.tightLists === \"undefined\") this.options.tightLists = true;\n  }\n\n  flushClose(size) {\n    if (this.closed) {\n      if (!this.atBlank()) this.out += \"\\n\";\n      if (size === null || size === undefined) size = 2;\n\n      if (size > 1) {\n        let delimMin = this.delim;\n        const trim = /\\s+$/.exec(delimMin);\n        if (trim) delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n\n        for (let i = 1; i < size; i++) this.out += delimMin + \"\\n\";\n      }\n\n      this.closed = false;\n    }\n  }\n\n  wrapBlock(delim, firstDelim, node, f) {\n    const old = this.delim;\n    this.write(firstDelim || delim);\n    this.delim += delim;\n    f();\n    this.delim = old;\n    this.closeBlock(node);\n  }\n\n  atBlank() {\n    return /(^|\\n)$/.test(this.out);\n  }\n\n  ensureNewLine() {\n    if (!this.atBlank()) this.out += \"\\n\";\n  }\n\n  write(content) {\n    this.flushClose();\n    if (this.delim && this.atBlank()) this.out += this.delim;\n    if (content) this.out += content;\n  }\n\n  closeBlock(node) {\n    this.closed = node;\n  }\n\n  text(text, escape) {\n    const lines = text.split(\"\\n\");\n\n    for (let i = 0; i < lines.length; i++) {\n      const startOfLine = this.atBlank() || this.closed;\n      this.write();\n      this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i];\n      if (i !== lines.length - 1) this.out += \"\\n\";\n    }\n  }\n\n  render(node, parent, index) {\n    if (typeof parent === \"number\") throw new Error(\"!\");\n    this.nodes[node.type.name](this, node, parent, index);\n  }\n\n  renderContent(parent) {\n    parent.forEach((node, _, i) => this.render(node, parent, i));\n  }\n\n  renderInline(parent) {\n    const active = [];\n    let trailing = \"\";\n\n    const progress = (node, _, index) => {\n      let marks = node ? node.marks : [];\n      if (node && node.type.name === \"hard_break\") marks = marks.filter(m => {\n        if (index + 1 === parent.childCount) return false;\n        const next = parent.child(index + 1);\n        return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text));\n      });\n      let leading = trailing;\n      trailing = \"\";\n\n      if (node && node.isText && marks.some(mark => {\n        const info = this.marks[mark.type.name];\n        return info && info.expelEnclosingWhitespace;\n      })) {\n        const [_, lead, inner, trail] = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text);\n        leading += lead;\n        trailing = trail;\n\n        if (lead || trail) {\n          node = inner ? node.withText(inner) : null;\n          if (!node) marks = active;\n        }\n      }\n\n      const inner = marks.length && marks[marks.length - 1],\n            noEsc = inner && this.marks[inner.type.name].escape === false;\n      const len = marks.length - (noEsc ? 1 : 0);\n\n      outer: for (let i = 0; i < len; i++) {\n        const mark = marks[i];\n        if (!this.marks[mark.type.name].mixable) break;\n\n        for (let j = 0; j < active.length; j++) {\n          const other = active[j];\n          if (!this.marks[other.type.name].mixable) break;\n\n          if (mark.eq(other)) {\n            if (i > j) marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));else if (j > i) marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));\n            continue outer;\n          }\n        }\n      }\n\n      let keep = 0;\n\n      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) ++keep;\n\n      while (keep < active.length) this.text(this.markString(active.pop(), false, parent, index), false);\n\n      if (leading) this.text(leading);\n\n      if (node) {\n        while (active.length < len) {\n          const add = marks[active.length];\n          active.push(add);\n          this.text(this.markString(add, true, parent, index), false);\n        }\n\n        if (noEsc && node.isText) this.text(this.markString(inner, true, parent, index) + node.text + this.markString(inner, false, parent, index + 1), false);else this.render(node, parent, index);\n      }\n    };\n\n    parent.forEach(progress);\n    progress(null, null, parent.childCount);\n  }\n\n  renderList(node, delim, firstDelim) {\n    if (this.closed && this.closed.type === node.type) this.flushClose(3);else if (this.inTightList) this.flushClose(1);\n    const isTight = typeof node.attrs.tight !== \"undefined\" ? node.attrs.tight : this.options.tightLists;\n    const prevTight = this.inTightList;\n    const prevList = this.inList;\n    this.inList = true;\n    this.inTightList = isTight;\n    node.forEach((child, _, i) => {\n      if (i && isTight) this.flushClose(1);\n      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));\n    });\n    this.inList = prevList;\n    this.inTightList = prevTight;\n  }\n\n  renderTable(node) {\n    this.flushClose(1);\n    let headerBuffer = \"\";\n    const prevTable = this.inTable;\n    this.inTable = true;\n    this.out += \"\\n\";\n    node.forEach((row, _, i) => {\n      if (headerBuffer) {\n        this.out += `${headerBuffer}|\\n`;\n        headerBuffer = undefined;\n      }\n\n      row.forEach((cell, _, j) => {\n        this.out += j === 0 ? \"| \" : \" | \";\n        cell.forEach(para => {\n          if (para.textContent === \"\") {\n            this.out += \"  \";\n          } else {\n            this.closed = false;\n            this.render(para, row, j);\n          }\n        });\n\n        if (i === 0) {\n          if (cell.attrs.alignment === \"center\") {\n            headerBuffer += \"|:---:\";\n          } else if (cell.attrs.alignment === \"left\") {\n            headerBuffer += \"|:---\";\n          } else if (cell.attrs.alignment === \"right\") {\n            headerBuffer += \"|---:\";\n          } else {\n            headerBuffer += \"|----\";\n          }\n        }\n      });\n      this.out += \" |\\n\";\n    });\n    this.inTable = prevTable;\n  }\n\n  esc(str = \"\", startOfLine) {\n    str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\");\n\n    if (startOfLine) {\n      str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\d+)\\./, \"$1\\\\.\");\n    }\n\n    if (this.inTable) {\n      str = str.replace(/\\|/gi, \"\\\\$&\");\n    }\n\n    return str;\n  }\n\n  quote(str) {\n    const wrap = str.indexOf('\"') === -1 ? '\"\"' : str.indexOf(\"'\") === -1 ? \"''\" : \"()\";\n    return wrap[0] + str + wrap[1];\n  }\n\n  repeat(str, n) {\n    let out = \"\";\n\n    for (let i = 0; i < n; i++) out += str;\n\n    return out;\n  }\n\n  markString(mark, open, parent, index) {\n    const info = this.marks[mark.type.name];\n    const value = open ? info.open : info.close;\n    return typeof value === \"string\" ? value : value(this, mark, parent, index);\n  }\n\n  getEnclosingWhitespace(text) {\n    return {\n      leading: (text.match(/^(\\s+)/) || [])[0],\n      trailing: (text.match(/(\\s+)$/) || [])[0]\n    };\n  }\n\n}\n\nexports.MarkdownSerializerState = MarkdownSerializerState;","map":{"version":3,"sources":["../../../src/lib/markdown/serializer.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarkdownSerializerState = exports.MarkdownSerializer = void 0;\nclass MarkdownSerializer {\n    constructor(nodes, marks) {\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    serialize(content, options) {\n        const state = new MarkdownSerializerState(this.nodes, this.marks, options);\n        state.renderContent(content);\n        return state.out;\n    }\n}\nexports.MarkdownSerializer = MarkdownSerializer;\nclass MarkdownSerializerState {\n    constructor(nodes, marks, options) {\n        this.nodes = nodes;\n        this.marks = marks;\n        this.delim = this.out = \"\";\n        this.closed = false;\n        this.inTightList = false;\n        this.options = options || {};\n        if (typeof this.options.tightLists === \"undefined\")\n            this.options.tightLists = true;\n    }\n    flushClose(size) {\n        if (this.closed) {\n            if (!this.atBlank())\n                this.out += \"\\n\";\n            if (size === null || size === undefined)\n                size = 2;\n            if (size > 1) {\n                let delimMin = this.delim;\n                const trim = /\\s+$/.exec(delimMin);\n                if (trim)\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                for (let i = 1; i < size; i++)\n                    this.out += delimMin + \"\\n\";\n            }\n            this.closed = false;\n        }\n    }\n    wrapBlock(delim, firstDelim, node, f) {\n        const old = this.delim;\n        this.write(firstDelim || delim);\n        this.delim += delim;\n        f();\n        this.delim = old;\n        this.closeBlock(node);\n    }\n    atBlank() {\n        return /(^|\\n)$/.test(this.out);\n    }\n    ensureNewLine() {\n        if (!this.atBlank())\n            this.out += \"\\n\";\n    }\n    write(content) {\n        this.flushClose();\n        if (this.delim && this.atBlank())\n            this.out += this.delim;\n        if (content)\n            this.out += content;\n    }\n    closeBlock(node) {\n        this.closed = node;\n    }\n    text(text, escape) {\n        const lines = text.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            const startOfLine = this.atBlank() || this.closed;\n            this.write();\n            this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i];\n            if (i !== lines.length - 1)\n                this.out += \"\\n\";\n        }\n    }\n    render(node, parent, index) {\n        if (typeof parent === \"number\")\n            throw new Error(\"!\");\n        this.nodes[node.type.name](this, node, parent, index);\n    }\n    renderContent(parent) {\n        parent.forEach((node, _, i) => this.render(node, parent, i));\n    }\n    renderInline(parent) {\n        const active = [];\n        let trailing = \"\";\n        const progress = (node, _, index) => {\n            let marks = node ? node.marks : [];\n            if (node && node.type.name === \"hard_break\")\n                marks = marks.filter(m => {\n                    if (index + 1 === parent.childCount)\n                        return false;\n                    const next = parent.child(index + 1);\n                    return (m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text)));\n                });\n            let leading = trailing;\n            trailing = \"\";\n            if (node &&\n                node.isText &&\n                marks.some(mark => {\n                    const info = this.marks[mark.type.name];\n                    return info && info.expelEnclosingWhitespace;\n                })) {\n                const [_, lead, inner, trail] = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text);\n                leading += lead;\n                trailing = trail;\n                if (lead || trail) {\n                    node = inner ? node.withText(inner) : null;\n                    if (!node)\n                        marks = active;\n                }\n            }\n            const inner = marks.length && marks[marks.length - 1], noEsc = inner && this.marks[inner.type.name].escape === false;\n            const len = marks.length - (noEsc ? 1 : 0);\n            outer: for (let i = 0; i < len; i++) {\n                const mark = marks[i];\n                if (!this.marks[mark.type.name].mixable)\n                    break;\n                for (let j = 0; j < active.length; j++) {\n                    const other = active[j];\n                    if (!this.marks[other.type.name].mixable)\n                        break;\n                    if (mark.eq(other)) {\n                        if (i > j)\n                            marks = marks\n                                .slice(0, j)\n                                .concat(mark)\n                                .concat(marks.slice(j, i))\n                                .concat(marks.slice(i + 1, len));\n                        else if (j > i)\n                            marks = marks\n                                .slice(0, i)\n                                .concat(marks.slice(i + 1, j))\n                                .concat(mark)\n                                .concat(marks.slice(j, len));\n                        continue outer;\n                    }\n                }\n            }\n            let keep = 0;\n            while (keep < Math.min(active.length, len) &&\n                marks[keep].eq(active[keep]))\n                ++keep;\n            while (keep < active.length)\n                this.text(this.markString(active.pop(), false, parent, index), false);\n            if (leading)\n                this.text(leading);\n            if (node) {\n                while (active.length < len) {\n                    const add = marks[active.length];\n                    active.push(add);\n                    this.text(this.markString(add, true, parent, index), false);\n                }\n                if (noEsc && node.isText)\n                    this.text(this.markString(inner, true, parent, index) +\n                        node.text +\n                        this.markString(inner, false, parent, index + 1), false);\n                else\n                    this.render(node, parent, index);\n            }\n        };\n        parent.forEach(progress);\n        progress(null, null, parent.childCount);\n    }\n    renderList(node, delim, firstDelim) {\n        if (this.closed && this.closed.type === node.type)\n            this.flushClose(3);\n        else if (this.inTightList)\n            this.flushClose(1);\n        const isTight = typeof node.attrs.tight !== \"undefined\"\n            ? node.attrs.tight\n            : this.options.tightLists;\n        const prevTight = this.inTightList;\n        const prevList = this.inList;\n        this.inList = true;\n        this.inTightList = isTight;\n        node.forEach((child, _, i) => {\n            if (i && isTight)\n                this.flushClose(1);\n            this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));\n        });\n        this.inList = prevList;\n        this.inTightList = prevTight;\n    }\n    renderTable(node) {\n        this.flushClose(1);\n        let headerBuffer = \"\";\n        const prevTable = this.inTable;\n        this.inTable = true;\n        this.out += \"\\n\";\n        node.forEach((row, _, i) => {\n            if (headerBuffer) {\n                this.out += `${headerBuffer}|\\n`;\n                headerBuffer = undefined;\n            }\n            row.forEach((cell, _, j) => {\n                this.out += j === 0 ? \"| \" : \" | \";\n                cell.forEach(para => {\n                    if (para.textContent === \"\") {\n                        this.out += \"  \";\n                    }\n                    else {\n                        this.closed = false;\n                        this.render(para, row, j);\n                    }\n                });\n                if (i === 0) {\n                    if (cell.attrs.alignment === \"center\") {\n                        headerBuffer += \"|:---:\";\n                    }\n                    else if (cell.attrs.alignment === \"left\") {\n                        headerBuffer += \"|:---\";\n                    }\n                    else if (cell.attrs.alignment === \"right\") {\n                        headerBuffer += \"|---:\";\n                    }\n                    else {\n                        headerBuffer += \"|----\";\n                    }\n                }\n            });\n            this.out += \" |\\n\";\n        });\n        this.inTable = prevTable;\n    }\n    esc(str = \"\", startOfLine) {\n        str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\");\n        if (startOfLine) {\n            str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\d+)\\./, \"$1\\\\.\");\n        }\n        if (this.inTable) {\n            str = str.replace(/\\|/gi, \"\\\\$&\");\n        }\n        return str;\n    }\n    quote(str) {\n        const wrap = str.indexOf('\"') === -1 ? '\"\"' : str.indexOf(\"'\") === -1 ? \"''\" : \"()\";\n        return wrap[0] + str + wrap[1];\n    }\n    repeat(str, n) {\n        let out = \"\";\n        for (let i = 0; i < n; i++)\n            out += str;\n        return out;\n    }\n    markString(mark, open, parent, index) {\n        const info = this.marks[mark.type.name];\n        const value = open ? info.open : info.close;\n        return typeof value === \"string\" ? value : value(this, mark, parent, index);\n    }\n    getEnclosingWhitespace(text) {\n        return {\n            leading: (text.match(/^(\\s+)/) || [])[0],\n            trailing: (text.match(/(\\s+)$/) || [])[0],\n        };\n    }\n}\nexports.MarkdownSerializerState = MarkdownSerializerState;\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"script"}