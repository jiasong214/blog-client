{"ast":null,"code":"import { Schema, Mark } from 'prosemirror-model';\nimport markdownit from 'markdown-it'; // ::Schema Document schema for the data model used by CommonMark.\n\nvar schema = new Schema({\n  nodes: {\n    doc: {\n      content: \"block+\"\n    },\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{\n        tag: \"p\"\n      }],\n      toDOM: function toDOM() {\n        return [\"p\", 0];\n      }\n    },\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{\n        tag: \"blockquote\"\n      }],\n      toDOM: function toDOM() {\n        return [\"blockquote\", 0];\n      }\n    },\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{\n        tag: \"hr\"\n      }],\n      toDOM: function toDOM() {\n        return [\"div\", [\"hr\"]];\n      }\n    },\n    heading: {\n      attrs: {\n        level: {\n          default: 1\n        }\n      },\n      content: \"(text | image)*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{\n        tag: \"h1\",\n        attrs: {\n          level: 1\n        }\n      }, {\n        tag: \"h2\",\n        attrs: {\n          level: 2\n        }\n      }, {\n        tag: \"h3\",\n        attrs: {\n          level: 3\n        }\n      }, {\n        tag: \"h4\",\n        attrs: {\n          level: 4\n        }\n      }, {\n        tag: \"h5\",\n        attrs: {\n          level: 5\n        }\n      }, {\n        tag: \"h6\",\n        attrs: {\n          level: 6\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"h\" + node.attrs.level, 0];\n      }\n    },\n    code_block: {\n      content: \"text*\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      marks: \"\",\n      attrs: {\n        params: {\n          default: \"\"\n        }\n      },\n      parseDOM: [{\n        tag: \"pre\",\n        preserveWhitespace: \"full\",\n        getAttrs: function (node) {\n          return {\n            params: node.getAttribute(\"data-params\") || \"\"\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"pre\", node.attrs.params ? {\n          \"data-params\": node.attrs.params\n        } : {}, [\"code\", 0]];\n      }\n    },\n    ordered_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {\n        order: {\n          default: 1\n        },\n        tight: {\n          default: false\n        }\n      },\n      parseDOM: [{\n        tag: \"ol\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n            tight: dom.hasAttribute(\"data-tight\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"ol\", {\n          start: node.attrs.order == 1 ? null : node.attrs.order,\n          \"data-tight\": node.attrs.tight ? \"true\" : null\n        }, 0];\n      }\n    },\n    bullet_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {\n        tight: {\n          default: false\n        }\n      },\n      parseDOM: [{\n        tag: \"ul\",\n        getAttrs: function (dom) {\n          return {\n            tight: dom.hasAttribute(\"data-tight\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"ul\", {\n          \"data-tight\": node.attrs.tight ? \"true\" : null\n        }, 0];\n      }\n    },\n    list_item: {\n      content: \"paragraph block*\",\n      defining: true,\n      parseDOM: [{\n        tag: \"li\"\n      }],\n      toDOM: function toDOM() {\n        return [\"li\", 0];\n      }\n    },\n    text: {\n      group: \"inline\"\n    },\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null\n        },\n        title: {\n          default: null\n        }\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{\n        tag: \"img[src]\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            src: dom.getAttribute(\"src\"),\n            title: dom.getAttribute(\"title\"),\n            alt: dom.getAttribute(\"alt\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"img\", node.attrs];\n      }\n    },\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{\n        tag: \"br\"\n      }],\n      toDOM: function toDOM() {\n        return [\"br\"];\n      }\n    }\n  },\n  marks: {\n    em: {\n      parseDOM: [{\n        tag: \"i\"\n      }, {\n        tag: \"em\"\n      }, {\n        style: \"font-style\",\n        getAttrs: function (value) {\n          return value == \"italic\" && null;\n        }\n      }],\n      toDOM: function toDOM() {\n        return [\"em\"];\n      }\n    },\n    strong: {\n      parseDOM: [{\n        tag: \"b\"\n      }, {\n        tag: \"strong\"\n      }, {\n        style: \"font-weight\",\n        getAttrs: function (value) {\n          return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null;\n        }\n      }],\n      toDOM: function toDOM() {\n        return [\"strong\"];\n      }\n    },\n    link: {\n      attrs: {\n        href: {},\n        title: {\n          default: null\n        }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: \"a[href]\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            href: dom.getAttribute(\"href\"),\n            title: dom.getAttribute(\"title\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"a\", node.attrs];\n      }\n    },\n    code: {\n      parseDOM: [{\n        tag: \"code\"\n      }],\n      toDOM: function toDOM() {\n        return [\"code\"];\n      }\n    }\n  }\n});\n\nfunction maybeMerge(a, b) {\n  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks)) {\n    return a.withText(a.text + b.text);\n  }\n} // Object used to track the context of a running parse.\n\n\nvar MarkdownParseState = function MarkdownParseState(schema, tokenHandlers) {\n  this.schema = schema;\n  this.stack = [{\n    type: schema.topNodeType,\n    content: []\n  }];\n  this.marks = Mark.none;\n  this.tokenHandlers = tokenHandlers;\n};\n\nMarkdownParseState.prototype.top = function top() {\n  return this.stack[this.stack.length - 1];\n};\n\nMarkdownParseState.prototype.push = function push(elt) {\n  if (this.stack.length) {\n    this.top().content.push(elt);\n  }\n}; // : (string)\n// Adds the given text to the current position in the document,\n// using the current marks as styling.\n\n\nMarkdownParseState.prototype.addText = function addText(text) {\n  if (!text) {\n    return;\n  }\n\n  var nodes = this.top().content,\n      last = nodes[nodes.length - 1];\n  var node = this.schema.text(text, this.marks),\n      merged;\n\n  if (last && (merged = maybeMerge(last, node))) {\n    nodes[nodes.length - 1] = merged;\n  } else {\n    nodes.push(node);\n  }\n}; // : (Mark)\n// Adds the given mark to the set of active marks.\n\n\nMarkdownParseState.prototype.openMark = function openMark(mark) {\n  this.marks = mark.addToSet(this.marks);\n}; // : (Mark)\n// Removes the given mark from the set of active marks.\n\n\nMarkdownParseState.prototype.closeMark = function closeMark(mark) {\n  this.marks = mark.removeFromSet(this.marks);\n};\n\nMarkdownParseState.prototype.parseTokens = function parseTokens(toks) {\n  for (var i = 0; i < toks.length; i++) {\n    var tok = toks[i];\n    var handler = this.tokenHandlers[tok.type];\n\n    if (!handler) {\n      throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\");\n    }\n\n    handler(this, tok, toks, i);\n  }\n}; // : (NodeType, ?Object, ?[Node]) → ?Node\n// Add a node at the current position.\n\n\nMarkdownParseState.prototype.addNode = function addNode(type, attrs, content) {\n  var node = type.createAndFill(attrs, content, this.marks);\n\n  if (!node) {\n    return null;\n  }\n\n  this.push(node);\n  return node;\n}; // : (NodeType, ?Object)\n// Wrap subsequent content in a node of the given type.\n\n\nMarkdownParseState.prototype.openNode = function openNode(type, attrs) {\n  this.stack.push({\n    type: type,\n    attrs: attrs,\n    content: []\n  });\n}; // : () → ?Node\n// Close and return the node that is currently on top of the stack.\n\n\nMarkdownParseState.prototype.closeNode = function closeNode() {\n  if (this.marks.length) {\n    this.marks = Mark.none;\n  }\n\n  var info = this.stack.pop();\n  return this.addNode(info.type, info.attrs, info.content);\n};\n\nfunction attrs(spec, token, tokens, i) {\n  if (spec.getAttrs) {\n    return spec.getAttrs(token, tokens, i);\n  } // For backwards compatibility when `attrs` is a Function\n  else if (spec.attrs instanceof Function) {\n      return spec.attrs(token);\n    } else {\n      return spec.attrs;\n    }\n} // Code content is represented as a single token with a `content`\n// property in Markdown-it.\n\n\nfunction noCloseToken(spec, type) {\n  return spec.noCloseToken || type == \"code_inline\" || type == \"code_block\" || type == \"fence\";\n}\n\nfunction withoutTrailingNewline(str) {\n  return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str;\n}\n\nfunction noOp() {}\n\nfunction tokenHandlers(schema, tokens) {\n  var handlers = Object.create(null);\n\n  var loop = function (type) {\n    var spec = tokens[type];\n\n    if (spec.block) {\n      var nodeType = schema.nodeType(spec.block);\n\n      if (noCloseToken(spec, type)) {\n        handlers[type] = function (state, tok, tokens, i) {\n          state.openNode(nodeType, attrs(spec, tok, tokens, i));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeNode();\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok, tokens, i) {\n          return state.openNode(nodeType, attrs(spec, tok, tokens, i));\n        };\n\n        handlers[type + \"_close\"] = function (state) {\n          return state.closeNode();\n        };\n      }\n    } else if (spec.node) {\n      var nodeType$1 = schema.nodeType(spec.node);\n\n      handlers[type] = function (state, tok, tokens, i) {\n        return state.addNode(nodeType$1, attrs(spec, tok, tokens, i));\n      };\n    } else if (spec.mark) {\n      var markType = schema.marks[spec.mark];\n\n      if (noCloseToken(spec, type)) {\n        handlers[type] = function (state, tok, tokens, i) {\n          state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeMark(markType);\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok, tokens, i) {\n          return state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n        };\n\n        handlers[type + \"_close\"] = function (state) {\n          return state.closeMark(markType);\n        };\n      }\n    } else if (spec.ignore) {\n      if (noCloseToken(spec, type)) {\n        handlers[type] = noOp;\n      } else {\n        handlers[type + '_open'] = noOp;\n        handlers[type + '_close'] = noOp;\n      }\n    } else {\n      throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec));\n    }\n  };\n\n  for (var type in tokens) loop(type);\n\n  handlers.text = function (state, tok) {\n    return state.addText(tok.content);\n  };\n\n  handlers.inline = function (state, tok) {\n    return state.parseTokens(tok.children);\n  };\n\n  handlers.softbreak = handlers.softbreak || function (state) {\n    return state.addText(\"\\n\");\n  };\n\n  return handlers;\n} // ::- A configuration of a Markdown parser. Such a parser uses\n// [markdown-it](https://github.com/markdown-it/markdown-it) to\n// tokenize a file, and then runs the custom rules it is given over\n// the tokens to create a ProseMirror document tree.\n\n\nvar MarkdownParser = function MarkdownParser(schema, tokenizer, tokens) {\n  // :: Object The value of the `tokens` object used to construct\n  // this parser. Can be useful to copy and modify to base other\n  // parsers on.\n  this.tokens = tokens;\n  this.schema = schema;\n  this.tokenizer = tokenizer;\n  this.tokenHandlers = tokenHandlers(schema, tokens);\n}; // :: (string) → Node\n// Parse a string as [CommonMark](http://commonmark.org/) markup,\n// and create a ProseMirror document as prescribed by this parser's\n// rules.\n\n\nMarkdownParser.prototype.parse = function parse(text) {\n  var state = new MarkdownParseState(this.schema, this.tokenHandlers),\n      doc;\n  state.parseTokens(this.tokenizer.parse(text, {}));\n\n  do {\n    doc = state.closeNode();\n  } while (state.stack.length);\n\n  return doc;\n};\n\nfunction listIsTight(tokens, i) {\n  while (++i < tokens.length) {\n    if (tokens[i].type != \"list_item_open\") {\n      return tokens[i].hidden;\n    }\n  }\n\n  return false;\n} // :: MarkdownParser\n// A parser parsing unextended [CommonMark](http://commonmark.org/),\n// without inline HTML, and producing a document in the basic schema.\n\n\nvar defaultMarkdownParser = new MarkdownParser(schema, markdownit(\"commonmark\", {\n  html: false\n}), {\n  blockquote: {\n    block: \"blockquote\"\n  },\n  paragraph: {\n    block: \"paragraph\"\n  },\n  list_item: {\n    block: \"list_item\"\n  },\n  bullet_list: {\n    block: \"bullet_list\",\n    getAttrs: function (_, tokens, i) {\n      return {\n        tight: listIsTight(tokens, i)\n      };\n    }\n  },\n  ordered_list: {\n    block: \"ordered_list\",\n    getAttrs: function (tok, tokens, i) {\n      return {\n        order: +tok.attrGet(\"start\") || 1,\n        tight: listIsTight(tokens, i)\n      };\n    }\n  },\n  heading: {\n    block: \"heading\",\n    getAttrs: function (tok) {\n      return {\n        level: +tok.tag.slice(1)\n      };\n    }\n  },\n  code_block: {\n    block: \"code_block\",\n    noCloseToken: true\n  },\n  fence: {\n    block: \"code_block\",\n    getAttrs: function (tok) {\n      return {\n        params: tok.info || \"\"\n      };\n    },\n    noCloseToken: true\n  },\n  hr: {\n    node: \"horizontal_rule\"\n  },\n  image: {\n    node: \"image\",\n    getAttrs: function (tok) {\n      return {\n        src: tok.attrGet(\"src\"),\n        title: tok.attrGet(\"title\") || null,\n        alt: tok.children[0] && tok.children[0].content || null\n      };\n    }\n  },\n  hardbreak: {\n    node: \"hard_break\"\n  },\n  em: {\n    mark: \"em\"\n  },\n  strong: {\n    mark: \"strong\"\n  },\n  link: {\n    mark: \"link\",\n    getAttrs: function (tok) {\n      return {\n        href: tok.attrGet(\"href\"),\n        title: tok.attrGet(\"title\") || null\n      };\n    }\n  },\n  code_inline: {\n    mark: \"code\",\n    noCloseToken: true\n  }\n}); // ::- A specification for serializing a ProseMirror document as\n// Markdown/CommonMark text.\n\nvar MarkdownSerializer = function MarkdownSerializer(nodes, marks) {\n  // :: Object<(MarkdownSerializerState, Node)> The node serializer\n  // functions for this serializer.\n  this.nodes = nodes; // :: Object The mark serializer info.\n\n  this.marks = marks;\n}; // :: (Node, ?Object) → string\n// Serialize the content of the given node to\n// [CommonMark](http://commonmark.org/).\n\n\nMarkdownSerializer.prototype.serialize = function serialize(content, options) {\n  var state = new MarkdownSerializerState(this.nodes, this.marks, options);\n  state.renderContent(content);\n  return state.out;\n}; // :: MarkdownSerializer\n// A serializer for the [basic schema](#schema).\n\n\nvar defaultMarkdownSerializer = new MarkdownSerializer({\n  blockquote: function blockquote(state, node) {\n    state.wrapBlock(\"> \", null, node, function () {\n      return state.renderContent(node);\n    });\n  },\n  code_block: function code_block(state, node) {\n    state.write(\"```\" + (node.attrs.params || \"\") + \"\\n\");\n    state.text(node.textContent, false);\n    state.ensureNewLine();\n    state.write(\"```\");\n    state.closeBlock(node);\n  },\n  heading: function heading(state, node) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \");\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n  horizontal_rule: function horizontal_rule(state, node) {\n    state.write(node.attrs.markup || \"---\");\n    state.closeBlock(node);\n  },\n  bullet_list: function bullet_list(state, node) {\n    state.renderList(node, \"  \", function () {\n      return (node.attrs.bullet || \"*\") + \" \";\n    });\n  },\n  ordered_list: function ordered_list(state, node) {\n    var start = node.attrs.order || 1;\n    var maxW = String(start + node.childCount - 1).length;\n    var space = state.repeat(\" \", maxW + 2);\n    state.renderList(node, space, function (i) {\n      var nStr = String(start + i);\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \";\n    });\n  },\n  list_item: function list_item(state, node) {\n    state.renderContent(node);\n  },\n  paragraph: function paragraph(state, node) {\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n  image: function image(state, node) {\n    state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + state.esc(node.attrs.src) + (node.attrs.title ? \" \" + state.quote(node.attrs.title) : \"\") + \")\");\n  },\n  hard_break: function hard_break(state, node, parent, index) {\n    for (var i = index + 1; i < parent.childCount; i++) {\n      if (parent.child(i).type != node.type) {\n        state.write(\"\\\\\\n\");\n        return;\n      }\n    }\n  },\n  text: function text(state, node) {\n    state.text(node.text);\n  }\n}, {\n  em: {\n    open: \"*\",\n    close: \"*\",\n    mixable: true,\n    expelEnclosingWhitespace: true\n  },\n  strong: {\n    open: \"**\",\n    close: \"**\",\n    mixable: true,\n    expelEnclosingWhitespace: true\n  },\n  link: {\n    open: function open(_state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n    },\n    close: function close(state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, -1) ? \">\" : \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\";\n    }\n  },\n  code: {\n    open: function open(_state, _mark, parent, index) {\n      return backticksFor(parent.child(index), -1);\n    },\n    close: function close(_state, _mark, parent, index) {\n      return backticksFor(parent.child(index - 1), 1);\n    },\n    escape: false\n  }\n});\n\nfunction backticksFor(node, side) {\n  var ticks = /`+/g,\n      m,\n      len = 0;\n\n  if (node.isText) {\n    while (m = ticks.exec(node.text)) {\n      len = Math.max(len, m[0].length);\n    }\n  }\n\n  var result = len > 0 && side > 0 ? \" `\" : \"`\";\n\n  for (var i = 0; i < len; i++) {\n    result += \"`\";\n  }\n\n  if (len > 0 && side < 0) {\n    result += \" \";\n  }\n\n  return result;\n}\n\nfunction isPlainURL(link, parent, index, side) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n    return false;\n  }\n\n  var content = parent.child(index + (side < 0 ? -1 : 0));\n\n  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link) {\n    return false;\n  }\n\n  if (index == (side < 0 ? 1 : parent.childCount - 1)) {\n    return true;\n  }\n\n  var next = parent.child(index + (side < 0 ? -2 : 1));\n  return !link.isInSet(next.marks);\n} // ::- This is an object used to track state and expose\n// methods related to markdown serialization. Instances are passed to\n// node and mark serialization methods (see `toMarkdown`).\n\n\nvar MarkdownSerializerState = function MarkdownSerializerState(nodes, marks, options) {\n  this.nodes = nodes;\n  this.marks = marks;\n  this.delim = this.out = \"\";\n  this.closed = false;\n  this.inTightList = false; // :: Object\n  // The options passed to the serializer.\n  // tightLists:: ?bool\n  // Whether to render lists in a tight style. This can be overridden\n  // on a node level by specifying a tight attribute on the node.\n  // Defaults to false.\n\n  this.options = options || {};\n\n  if (typeof this.options.tightLists == \"undefined\") {\n    this.options.tightLists = false;\n  }\n};\n\nMarkdownSerializerState.prototype.flushClose = function flushClose(size) {\n  if (this.closed) {\n    if (!this.atBlank()) {\n      this.out += \"\\n\";\n    }\n\n    if (size == null) {\n      size = 2;\n    }\n\n    if (size > 1) {\n      var delimMin = this.delim;\n      var trim = /\\s+$/.exec(delimMin);\n\n      if (trim) {\n        delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n      }\n\n      for (var i = 1; i < size; i++) {\n        this.out += delimMin + \"\\n\";\n      }\n    }\n\n    this.closed = false;\n  }\n}; // :: (string, ?string, Node, ())\n// Render a block, prefixing each line with `delim`, and the first\n// line in `firstDelim`. `node` should be the node that is closed at\n// the end of the block, and `f` is a function that renders the\n// content of the block.\n\n\nMarkdownSerializerState.prototype.wrapBlock = function wrapBlock(delim, firstDelim, node, f) {\n  var old = this.delim;\n  this.write(firstDelim || delim);\n  this.delim += delim;\n  f();\n  this.delim = old;\n  this.closeBlock(node);\n};\n\nMarkdownSerializerState.prototype.atBlank = function atBlank() {\n  return /(^|\\n)$/.test(this.out);\n}; // :: ()\n// Ensure the current content ends with a newline.\n\n\nMarkdownSerializerState.prototype.ensureNewLine = function ensureNewLine() {\n  if (!this.atBlank()) {\n    this.out += \"\\n\";\n  }\n}; // :: (?string)\n// Prepare the state for writing output (closing closed paragraphs,\n// adding delimiters, and so on), and then optionally add content\n// (unescaped) to the output.\n\n\nMarkdownSerializerState.prototype.write = function write(content) {\n  this.flushClose();\n\n  if (this.delim && this.atBlank()) {\n    this.out += this.delim;\n  }\n\n  if (content) {\n    this.out += content;\n  }\n}; // :: (Node)\n// Close the block for the given node.\n\n\nMarkdownSerializerState.prototype.closeBlock = function closeBlock(node) {\n  this.closed = node;\n}; // :: (string, ?bool)\n// Add the given text to the document. When escape is not `false`,\n// it will be escaped.\n\n\nMarkdownSerializerState.prototype.text = function text(text$1, escape) {\n  var lines = text$1.split(\"\\n\");\n\n  for (var i = 0; i < lines.length; i++) {\n    var startOfLine = this.atBlank() || this.closed;\n    this.write();\n    this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i];\n\n    if (i != lines.length - 1) {\n      this.out += \"\\n\";\n    }\n  }\n}; // :: (Node)\n// Render the given node as a block.\n\n\nMarkdownSerializerState.prototype.render = function render(node, parent, index) {\n  if (typeof parent == \"number\") {\n    throw new Error(\"!\");\n  }\n\n  if (!this.nodes[node.type.name]) {\n    throw new Error(\"Token type `\" + node.type.name + \"` not supported by Markdown renderer\");\n  }\n\n  this.nodes[node.type.name](this, node, parent, index);\n}; // :: (Node)\n// Render the contents of `parent` as block nodes.\n\n\nMarkdownSerializerState.prototype.renderContent = function renderContent(parent) {\n  var this$1 = this;\n  parent.forEach(function (node, _, i) {\n    return this$1.render(node, parent, i);\n  });\n}; // :: (Node)\n// Render the contents of `parent` as inline content.\n\n\nMarkdownSerializerState.prototype.renderInline = function renderInline(parent) {\n  var this$1 = this;\n  var active = [],\n      trailing = \"\";\n\n  var progress = function (node, _, index) {\n    var marks = node ? node.marks : []; // Remove marks from `hard_break` that are the last node inside\n    // that mark to prevent parser edge cases with new lines just\n    // before closing marks.\n    // (FIXME it'd be nice if we had a schema-agnostic way to\n    // identify nodes that serialize as hard breaks)\n\n    if (node && node.type.name === \"hard_break\") {\n      marks = marks.filter(function (m) {\n        if (index + 1 == parent.childCount) {\n          return false;\n        }\n\n        var next = parent.child(index + 1);\n        return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text));\n      });\n    }\n\n    var leading = trailing;\n    trailing = \"\"; // If whitespace has to be expelled from the node, adjust\n    // leading and trailing accordingly.\n\n    if (node && node.isText && marks.some(function (mark) {\n      var info = this$1.marks[mark.type.name];\n      return info && info.expelEnclosingWhitespace;\n    })) {\n      var ref = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text);\n      var _$1 = ref[0];\n      var lead = ref[1];\n      var inner$1 = ref[2];\n      var trail = ref[3];\n      leading += lead;\n      trailing = trail;\n\n      if (lead || trail) {\n        node = inner$1 ? node.withText(inner$1) : null;\n\n        if (!node) {\n          marks = active;\n        }\n      }\n    }\n\n    var inner = marks.length && marks[marks.length - 1],\n        noEsc = inner && this$1.marks[inner.type.name].escape === false;\n    var len = marks.length - (noEsc ? 1 : 0); // Try to reorder 'mixable' marks, such as em and strong, which\n    // in Markdown may be opened and closed in different order, so\n    // that order of the marks for the token matches the order in\n    // active.\n\n    outer: for (var i = 0; i < len; i++) {\n      var mark = marks[i];\n\n      if (!this$1.marks[mark.type.name].mixable) {\n        break;\n      }\n\n      for (var j = 0; j < active.length; j++) {\n        var other = active[j];\n\n        if (!this$1.marks[other.type.name].mixable) {\n          break;\n        }\n\n        if (mark.eq(other)) {\n          if (i > j) {\n            marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));\n          } else if (j > i) {\n            marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));\n          }\n\n          continue outer;\n        }\n      }\n    } // Find the prefix of the mark set that didn't change\n\n\n    var keep = 0;\n\n    while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n      ++keep;\n    } // Close the marks that need to be closed\n\n\n    while (keep < active.length) {\n      this$1.text(this$1.markString(active.pop(), false, parent, index), false);\n    } // Output any previously expelled trailing whitespace outside the marks\n\n\n    if (leading) {\n      this$1.text(leading);\n    } // Open the marks that need to be opened\n\n\n    if (node) {\n      while (active.length < len) {\n        var add = marks[active.length];\n        active.push(add);\n        this$1.text(this$1.markString(add, true, parent, index), false);\n      } // Render the node. Special case code marks, since their content\n      // may not be escaped.\n\n\n      if (noEsc && node.isText) {\n        this$1.text(this$1.markString(inner, true, parent, index) + node.text + this$1.markString(inner, false, parent, index + 1), false);\n      } else {\n        this$1.render(node, parent, index);\n      }\n    }\n  };\n\n  parent.forEach(progress);\n  progress(null, null, parent.childCount);\n}; // :: (Node, string, (number) → string)\n// Render a node's content as a list. `delim` should be the extra\n// indentation added to all lines except the first in an item,\n// `firstDelim` is a function going from an item index to a\n// delimiter for the first line of the item.\n\n\nMarkdownSerializerState.prototype.renderList = function renderList(node, delim, firstDelim) {\n  var this$1 = this;\n\n  if (this.closed && this.closed.type == node.type) {\n    this.flushClose(3);\n  } else if (this.inTightList) {\n    this.flushClose(1);\n  }\n\n  var isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists;\n  var prevTight = this.inTightList;\n  this.inTightList = isTight;\n  node.forEach(function (child, _, i) {\n    if (i && isTight) {\n      this$1.flushClose(1);\n    }\n\n    this$1.wrapBlock(delim, firstDelim(i), node, function () {\n      return this$1.render(child, node, i);\n    });\n  });\n  this.inTightList = prevTight;\n}; // :: (string, ?bool) → string\n// Escape the given string so that it can safely appear in Markdown\n// content. If `startOfLine` is true, also escape characters that\n// have special meaning only at the start of the line.\n\n\nMarkdownSerializerState.prototype.esc = function esc(str, startOfLine) {\n  str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\");\n\n  if (startOfLine) {\n    str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\s*\\d+)\\./, \"$1\\\\.\");\n  }\n\n  return str;\n};\n\nMarkdownSerializerState.prototype.quote = function quote(str) {\n  var wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\";\n  return wrap[0] + str + wrap[1];\n}; // :: (string, number) → string\n// Repeat the given string `n` times.\n\n\nMarkdownSerializerState.prototype.repeat = function repeat(str, n) {\n  var out = \"\";\n\n  for (var i = 0; i < n; i++) {\n    out += str;\n  }\n\n  return out;\n}; // : (Mark, bool, string?) → string\n// Get the markdown string for a given opening or closing mark.\n\n\nMarkdownSerializerState.prototype.markString = function markString(mark, open, parent, index) {\n  var info = this.marks[mark.type.name];\n  var value = open ? info.open : info.close;\n  return typeof value == \"string\" ? value : value(this, mark, parent, index);\n}; // :: (string) → { leading: ?string, trailing: ?string }\n// Get leading and trailing whitespace from a string. Values of\n// leading or trailing property of the return object will be undefined\n// if there is no match.\n\n\nMarkdownSerializerState.prototype.getEnclosingWhitespace = function getEnclosingWhitespace(text) {\n  return {\n    leading: (text.match(/^(\\s+)/) || [])[0],\n    trailing: (text.match(/(\\s+)$/) || [])[0]\n  };\n};\n\nexport { MarkdownParser, MarkdownSerializer, MarkdownSerializerState, defaultMarkdownParser, defaultMarkdownSerializer, schema };","map":{"version":3,"sources":["../src/schema.js","../src/from_markdown.js","../src/to_markdown.js"],"names":["let","nodeType","text","this","inner"],"mappings":"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","sourcesContent":["import {Schema} from \"prosemirror-model\"\n\n// ::Schema Document schema for the data model used by CommonMark.\nexport const schema = new Schema({\n  nodes: {\n    doc: {\n      content: \"block+\"\n    },\n\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{tag: \"p\"}],\n      toDOM() { return [\"p\", 0] }\n    },\n\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{tag: \"blockquote\"}],\n      toDOM() { return [\"blockquote\", 0] }\n    },\n\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{tag: \"hr\"}],\n      toDOM() { return [\"div\", [\"hr\"]] }\n    },\n\n    heading: {\n      attrs: {level: {default: 1}},\n      content: \"(text | image)*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n                 {tag: \"h2\", attrs: {level: 2}},\n                 {tag: \"h3\", attrs: {level: 3}},\n                 {tag: \"h4\", attrs: {level: 4}},\n                 {tag: \"h5\", attrs: {level: 5}},\n                 {tag: \"h6\", attrs: {level: 6}}],\n      toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n    },\n\n    code_block: {\n      content: \"text*\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      marks: \"\",\n      attrs: {params: {default: \"\"}},\n      parseDOM: [{tag: \"pre\", preserveWhitespace: \"full\", getAttrs: node => (\n        {params: node.getAttribute(\"data-params\") || \"\"}\n      )}],\n      toDOM(node) { return [\"pre\", node.attrs.params ? {\"data-params\": node.attrs.params} : {}, [\"code\", 0]] }\n    },\n\n    ordered_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {order: {default: 1}, tight: {default: false}},\n      parseDOM: [{tag: \"ol\", getAttrs(dom) {\n        return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n                tight: dom.hasAttribute(\"data-tight\")}\n      }}],\n      toDOM(node) {\n        return [\"ol\", {start: node.attrs.order == 1 ? null : node.attrs.order,\n                       \"data-tight\": node.attrs.tight ? \"true\" : null}, 0]\n      }\n    },\n\n    bullet_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {tight: {default: false}},\n      parseDOM: [{tag: \"ul\", getAttrs: dom => ({tight: dom.hasAttribute(\"data-tight\")})}],\n      toDOM(node) { return [\"ul\", {\"data-tight\": node.attrs.tight ? \"true\" : null}, 0] }\n    },\n\n    list_item: {\n      content: \"paragraph block*\",\n      defining: true,\n      parseDOM: [{tag: \"li\"}],\n      toDOM() { return [\"li\", 0] }\n    },\n\n    text: {\n      group: \"inline\"\n    },\n\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {default: null},\n        title: {default: null}\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{tag: \"img[src]\", getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        }\n      }}],\n      toDOM(node) { return [\"img\", node.attrs] }\n    },\n\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{tag: \"br\"}],\n      toDOM() { return [\"br\"] }\n    }\n  },\n\n  marks: {\n    em: {\n      parseDOM: [{tag: \"i\"}, {tag: \"em\"},\n                 {style: \"font-style\", getAttrs: value => value == \"italic\" && null}],\n      toDOM() { return [\"em\"] }\n    },\n\n    strong: {\n      parseDOM: [{tag: \"b\"}, {tag: \"strong\"},\n                 {style: \"font-weight\", getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null}],\n      toDOM() { return [\"strong\"] }\n    },\n\n    link: {\n      attrs: {\n        href: {},\n        title: {default: null}\n      },\n      inclusive: false,\n      parseDOM: [{tag: \"a[href]\", getAttrs(dom) {\n        return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n      }}],\n      toDOM(node) { return [\"a\", node.attrs] }\n    },\n\n    code: {\n      parseDOM: [{tag: \"code\"}],\n      toDOM() { return [\"code\"] }\n    }\n  }\n})\n","import markdownit from \"markdown-it\"\nimport {schema} from \"./schema\"\nimport {Mark} from \"prosemirror-model\"\n\nfunction maybeMerge(a, b) {\n  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks))\n    return a.withText(a.text + b.text)\n}\n\n// Object used to track the context of a running parse.\nclass MarkdownParseState {\n  constructor(schema, tokenHandlers) {\n    this.schema = schema\n    this.stack = [{type: schema.topNodeType, content: []}]\n    this.marks = Mark.none\n    this.tokenHandlers = tokenHandlers\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1]\n  }\n\n  push(elt) {\n    if (this.stack.length) this.top().content.push(elt)\n  }\n\n  // : (string)\n  // Adds the given text to the current position in the document,\n  // using the current marks as styling.\n  addText(text) {\n    if (!text) return\n    let nodes = this.top().content, last = nodes[nodes.length - 1]\n    let node = this.schema.text(text, this.marks), merged\n    if (last && (merged = maybeMerge(last, node))) nodes[nodes.length - 1] = merged\n    else nodes.push(node)\n  }\n\n  // : (Mark)\n  // Adds the given mark to the set of active marks.\n  openMark(mark) {\n    this.marks = mark.addToSet(this.marks)\n  }\n\n  // : (Mark)\n  // Removes the given mark from the set of active marks.\n  closeMark(mark) {\n    this.marks = mark.removeFromSet(this.marks)\n  }\n\n  parseTokens(toks) {\n    for (let i = 0; i < toks.length; i++) {\n      let tok = toks[i]\n      let handler = this.tokenHandlers[tok.type]\n      if (!handler)\n        throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\")\n      handler(this, tok, toks, i)\n    }\n  }\n\n  // : (NodeType, ?Object, ?[Node]) → ?Node\n  // Add a node at the current position.\n  addNode(type, attrs, content) {\n    let node = type.createAndFill(attrs, content, this.marks)\n    if (!node) return null\n    this.push(node)\n    return node\n  }\n\n  // : (NodeType, ?Object)\n  // Wrap subsequent content in a node of the given type.\n  openNode(type, attrs) {\n    this.stack.push({type: type, attrs: attrs, content: []})\n  }\n\n  // : () → ?Node\n  // Close and return the node that is currently on top of the stack.\n  closeNode() {\n    if (this.marks.length) this.marks = Mark.none\n    let info = this.stack.pop()\n    return this.addNode(info.type, info.attrs, info.content)\n  }\n}\n\nfunction attrs(spec, token, tokens, i) {\n  if (spec.getAttrs) return spec.getAttrs(token, tokens, i)\n  // For backwards compatibility when `attrs` is a Function\n  else if (spec.attrs instanceof Function) return spec.attrs(token)\n  else return spec.attrs\n}\n\n// Code content is represented as a single token with a `content`\n// property in Markdown-it.\nfunction noCloseToken(spec, type) {\n  return spec.noCloseToken || type == \"code_inline\" || type == \"code_block\" || type == \"fence\"\n}\n\nfunction withoutTrailingNewline(str) {\n  return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str\n}\n\nfunction noOp() {}\n\nfunction tokenHandlers(schema, tokens) {\n  let handlers = Object.create(null)\n  for (let type in tokens) {\n    let spec = tokens[type]\n    if (spec.block) {\n      let nodeType = schema.nodeType(spec.block)\n      if (noCloseToken(spec, type)) {\n        handlers[type] = (state, tok, tokens, i) => {\n          state.openNode(nodeType, attrs(spec, tok, tokens, i))\n          state.addText(withoutTrailingNewline(tok.content))\n          state.closeNode()\n        }\n      } else {\n        handlers[type + \"_open\"] = (state, tok, tokens, i) => state.openNode(nodeType, attrs(spec, tok, tokens, i))\n        handlers[type + \"_close\"] = state => state.closeNode()\n      }\n    } else if (spec.node) {\n      let nodeType = schema.nodeType(spec.node)\n      handlers[type] = (state, tok, tokens, i) => state.addNode(nodeType, attrs(spec, tok, tokens, i))\n    } else if (spec.mark) {\n      let markType = schema.marks[spec.mark]\n      if (noCloseToken(spec, type)) {\n        handlers[type] = (state, tok, tokens, i) => {\n          state.openMark(markType.create(attrs(spec, tok, tokens, i)))\n          state.addText(withoutTrailingNewline(tok.content))\n          state.closeMark(markType)\n        }\n      } else {\n        handlers[type + \"_open\"] = (state, tok, tokens, i) => state.openMark(markType.create(attrs(spec, tok, tokens, i)))\n        handlers[type + \"_close\"] = state => state.closeMark(markType)\n      }\n    } else if (spec.ignore) {\n      if (noCloseToken(spec, type)) {\n        handlers[type] = noOp\n      } else {\n        handlers[type + '_open'] = noOp\n        handlers[type + '_close'] = noOp\n      }\n    } else {\n      throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec))\n    }\n  }\n\n  handlers.text = (state, tok) => state.addText(tok.content)\n  handlers.inline = (state, tok) => state.parseTokens(tok.children)\n  handlers.softbreak = handlers.softbreak || (state => state.addText(\"\\n\"))\n\n  return handlers\n}\n\n// ::- A configuration of a Markdown parser. Such a parser uses\n// [markdown-it](https://github.com/markdown-it/markdown-it) to\n// tokenize a file, and then runs the custom rules it is given over\n// the tokens to create a ProseMirror document tree.\nexport class MarkdownParser {\n  // :: (Schema, MarkdownIt, Object)\n  // Create a parser with the given configuration. You can configure\n  // the markdown-it parser to parse the dialect you want, and provide\n  // a description of the ProseMirror entities those tokens map to in\n  // the `tokens` object, which maps token names to descriptions of\n  // what to do with them. Such a description is an object, and may\n  // have the following properties:\n  //\n  // **`node`**`: ?string`\n  //   : This token maps to a single node, whose type can be looked up\n  //     in the schema under the given name. Exactly one of `node`,\n  //     `block`, or `mark` must be set.\n  //\n  // **`block`**`: ?string`\n  //   : This token (unless `noCloseToken` is true) comes in `_open`\n  //     and `_close` variants (which are appended to the base token\n  //     name provides a the object property), and wraps a block of\n  //     content. The block should be wrapped in a node of the type\n  //     named to by the property's value. If the token does not have\n  //     `_open` or `_close`, use the `noCloseToken` option.\n  //\n  // **`mark`**`: ?string`\n  //   : This token (again, unless `noCloseToken` is true) also comes\n  //     in `_open` and `_close` variants, but should add a mark\n  //     (named by the value) to its content, rather than wrapping it\n  //     in a node.\n  //\n  // **`attrs`**`: ?Object`\n  //   : Attributes for the node or mark. When `getAttrs` is provided,\n  //     it takes precedence.\n  //\n  // **`getAttrs`**`: ?(MarkdownToken) → Object`\n  //   : A function used to compute the attributes for the node or mark\n  //     that takes a [markdown-it\n  //     token](https://markdown-it.github.io/markdown-it/#Token) and\n  //     returns an attribute object.\n  //\n  // **`noCloseToken`**`: ?boolean`\n  //   : Indicates that the [markdown-it\n  //     token](https://markdown-it.github.io/markdown-it/#Token) has\n  //     no `_open` or `_close` for the nodes. This defaults to `true`\n  //     for `code_inline`, `code_block` and `fence`.\n  //\n  // **`ignore`**`: ?bool`\n  //   : When true, ignore content for the matched token.\n  constructor(schema, tokenizer, tokens) {\n    // :: Object The value of the `tokens` object used to construct\n    // this parser. Can be useful to copy and modify to base other\n    // parsers on.\n    this.tokens = tokens\n    this.schema = schema\n    this.tokenizer = tokenizer\n    this.tokenHandlers = tokenHandlers(schema, tokens)\n  }\n\n  // :: (string) → Node\n  // Parse a string as [CommonMark](http://commonmark.org/) markup,\n  // and create a ProseMirror document as prescribed by this parser's\n  // rules.\n  parse(text) {\n    let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc\n    state.parseTokens(this.tokenizer.parse(text, {}))\n    do { doc = state.closeNode() } while (state.stack.length)\n    return doc\n  }\n}\n\nfunction listIsTight(tokens, i) {\n  while (++i < tokens.length)\n    if (tokens[i].type != \"list_item_open\") return tokens[i].hidden\n  return false\n}\n\n// :: MarkdownParser\n// A parser parsing unextended [CommonMark](http://commonmark.org/),\n// without inline HTML, and producing a document in the basic schema.\nexport const defaultMarkdownParser = new MarkdownParser(schema, markdownit(\"commonmark\", {html: false}), {\n  blockquote: {block: \"blockquote\"},\n  paragraph: {block: \"paragraph\"},\n  list_item: {block: \"list_item\"},\n  bullet_list: {block: \"bullet_list\", getAttrs: (_, tokens, i) => ({tight: listIsTight(tokens, i)})},\n  ordered_list: {block: \"ordered_list\", getAttrs: (tok, tokens, i) => ({\n    order: +tok.attrGet(\"start\") || 1,\n    tight: listIsTight(tokens, i)\n  })},\n  heading: {block: \"heading\", getAttrs: tok => ({level: +tok.tag.slice(1)})},\n  code_block: {block: \"code_block\", noCloseToken: true},\n  fence: {block: \"code_block\", getAttrs: tok => ({params: tok.info || \"\"}), noCloseToken: true},\n  hr: {node: \"horizontal_rule\"},\n  image: {node: \"image\", getAttrs: tok => ({\n    src: tok.attrGet(\"src\"),\n    title: tok.attrGet(\"title\") || null,\n    alt: tok.children[0] && tok.children[0].content || null\n  })},\n  hardbreak: {node: \"hard_break\"},\n\n  em: {mark: \"em\"},\n  strong: {mark: \"strong\"},\n  link: {mark: \"link\", getAttrs: tok => ({\n    href: tok.attrGet(\"href\"),\n    title: tok.attrGet(\"title\") || null\n  })},\n  code_inline: {mark: \"code\", noCloseToken: true}\n})\n","// ::- A specification for serializing a ProseMirror document as\n// Markdown/CommonMark text.\nexport class MarkdownSerializer {\n  // :: (Object<(state: MarkdownSerializerState, node: Node, parent: Node, index: number)>, Object)\n  // Construct a serializer with the given configuration. The `nodes`\n  // object should map node names in a given schema to function that\n  // take a serializer state and such a node, and serialize the node.\n  //\n  // The `marks` object should hold objects with `open` and `close`\n  // properties, which hold the strings that should appear before and\n  // after a piece of text marked that way, either directly or as a\n  // function that takes a serializer state and a mark, and returns a\n  // string. `open` and `close` can also be functions, which will be\n  // called as\n  //\n  //     (state: MarkdownSerializerState, mark: Mark,\n  //      parent: Fragment, index: number) → string\n  //\n  // Where `parent` and `index` allow you to inspect the mark's\n  // context to see which nodes it applies to.\n  //\n  // Mark information objects can also have a `mixable` property\n  // which, when `true`, indicates that the order in which the mark's\n  // opening and closing syntax appears relative to other mixable\n  // marks can be varied. (For example, you can say `**a *b***` and\n  // `*a **b***`, but not `` `a *b*` ``.)\n  //\n  // To disable character escaping in a mark, you can give it an\n  // `escape` property of `false`. Such a mark has to have the highest\n  // precedence (must always be the innermost mark).\n  //\n  // The `expelEnclosingWhitespace` mark property causes the\n  // serializer to move enclosing whitespace from inside the marks to\n  // outside the marks. This is necessary for emphasis marks as\n  // CommonMark does not permit enclosing whitespace inside emphasis\n  // marks, see: http://spec.commonmark.org/0.26/#example-330\n  constructor(nodes, marks) {\n    // :: Object<(MarkdownSerializerState, Node)> The node serializer\n    // functions for this serializer.\n    this.nodes = nodes\n    // :: Object The mark serializer info.\n    this.marks = marks\n  }\n\n  // :: (Node, ?Object) → string\n  // Serialize the content of the given node to\n  // [CommonMark](http://commonmark.org/).\n  serialize(content, options) {\n    let state = new MarkdownSerializerState(this.nodes, this.marks, options)\n    state.renderContent(content)\n    return state.out\n  }\n}\n\n// :: MarkdownSerializer\n// A serializer for the [basic schema](#schema).\nexport const defaultMarkdownSerializer = new MarkdownSerializer({\n  blockquote(state, node) {\n    state.wrapBlock(\"> \", null, node, () => state.renderContent(node))\n  },\n  code_block(state, node) {\n    state.write(\"```\" + (node.attrs.params || \"\") + \"\\n\")\n    state.text(node.textContent, false)\n    state.ensureNewLine()\n    state.write(\"```\")\n    state.closeBlock(node)\n  },\n  heading(state, node) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \")\n    state.renderInline(node)\n    state.closeBlock(node)\n  },\n  horizontal_rule(state, node) {\n    state.write(node.attrs.markup || \"---\")\n    state.closeBlock(node)\n  },\n  bullet_list(state, node) {\n    state.renderList(node, \"  \", () => (node.attrs.bullet || \"*\") + \" \")\n  },\n  ordered_list(state, node) {\n    let start = node.attrs.order || 1\n    let maxW = String(start + node.childCount - 1).length\n    let space = state.repeat(\" \", maxW + 2)\n    state.renderList(node, space, i => {\n      let nStr = String(start + i)\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \"\n    })\n  },\n  list_item(state, node) {\n    state.renderContent(node)\n  },\n  paragraph(state, node) {\n    state.renderInline(node)\n    state.closeBlock(node)\n  },\n\n  image(state, node) {\n    state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + state.esc(node.attrs.src) +\n                (node.attrs.title ? \" \" + state.quote(node.attrs.title) : \"\") + \")\")\n  },\n  hard_break(state, node, parent, index) {\n    for (let i = index + 1; i < parent.childCount; i++)\n      if (parent.child(i).type != node.type) {\n        state.write(\"\\\\\\n\")\n        return\n      }\n  },\n  text(state, node) {\n    state.text(node.text)\n  }\n}, {\n  em: {open: \"*\", close: \"*\", mixable: true, expelEnclosingWhitespace: true},\n  strong: {open: \"**\", close: \"**\", mixable: true, expelEnclosingWhitespace: true},\n  link: {\n    open(_state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\"\n    },\n    close(state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, -1) ? \">\"\n        : \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\"\n    }\n  },\n  code: {open(_state, _mark, parent, index) { return backticksFor(parent.child(index), -1) },\n         close(_state, _mark, parent, index) { return backticksFor(parent.child(index - 1), 1) },\n         escape: false}\n})\n\nfunction backticksFor(node, side) {\n  let ticks = /`+/g, m, len = 0\n  if (node.isText) while (m = ticks.exec(node.text)) len = Math.max(len, m[0].length)\n  let result = len > 0 && side > 0 ? \" `\" : \"`\"\n  for (let i = 0; i < len; i++) result += \"`\"\n  if (len > 0 && side < 0) result += \" \"\n  return result\n}\n\nfunction isPlainURL(link, parent, index, side) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) return false\n  let content = parent.child(index + (side < 0 ? -1 : 0))\n  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link) return false\n  if (index == (side < 0 ? 1 : parent.childCount - 1)) return true\n  let next = parent.child(index + (side < 0 ? -2 : 1))\n  return !link.isInSet(next.marks)\n}\n\n// ::- This is an object used to track state and expose\n// methods related to markdown serialization. Instances are passed to\n// node and mark serialization methods (see `toMarkdown`).\nexport class MarkdownSerializerState {\n  constructor(nodes, marks, options) {\n    this.nodes = nodes\n    this.marks = marks\n    this.delim = this.out = \"\"\n    this.closed = false\n    this.inTightList = false\n    // :: Object\n    // The options passed to the serializer.\n    //   tightLists:: ?bool\n    //   Whether to render lists in a tight style. This can be overridden\n    //   on a node level by specifying a tight attribute on the node.\n    //   Defaults to false.\n    this.options = options || {}\n    if (typeof this.options.tightLists == \"undefined\")\n      this.options.tightLists = false\n  }\n\n  flushClose(size) {\n    if (this.closed) {\n      if (!this.atBlank()) this.out += \"\\n\"\n      if (size == null) size = 2\n      if (size > 1) {\n        let delimMin = this.delim\n        let trim = /\\s+$/.exec(delimMin)\n        if (trim) delimMin = delimMin.slice(0, delimMin.length - trim[0].length)\n        for (let i = 1; i < size; i++)\n          this.out += delimMin + \"\\n\"\n      }\n      this.closed = false\n    }\n  }\n\n  // :: (string, ?string, Node, ())\n  // Render a block, prefixing each line with `delim`, and the first\n  // line in `firstDelim`. `node` should be the node that is closed at\n  // the end of the block, and `f` is a function that renders the\n  // content of the block.\n  wrapBlock(delim, firstDelim, node, f) {\n    let old = this.delim\n    this.write(firstDelim || delim)\n    this.delim += delim\n    f()\n    this.delim = old\n    this.closeBlock(node)\n  }\n\n  atBlank() {\n    return /(^|\\n)$/.test(this.out)\n  }\n\n  // :: ()\n  // Ensure the current content ends with a newline.\n  ensureNewLine() {\n    if (!this.atBlank()) this.out += \"\\n\"\n  }\n\n  // :: (?string)\n  // Prepare the state for writing output (closing closed paragraphs,\n  // adding delimiters, and so on), and then optionally add content\n  // (unescaped) to the output.\n  write(content) {\n    this.flushClose()\n    if (this.delim && this.atBlank())\n      this.out += this.delim\n    if (content) this.out += content\n  }\n\n  // :: (Node)\n  // Close the block for the given node.\n  closeBlock(node) {\n    this.closed = node\n  }\n\n  // :: (string, ?bool)\n  // Add the given text to the document. When escape is not `false`,\n  // it will be escaped.\n  text(text, escape) {\n    let lines = text.split(\"\\n\")\n    for (let i = 0; i < lines.length; i++) {\n      var startOfLine = this.atBlank() || this.closed\n      this.write()\n      this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i]\n      if (i != lines.length - 1) this.out += \"\\n\"\n    }\n  }\n\n  // :: (Node)\n  // Render the given node as a block.\n  render(node, parent, index) {\n    if (typeof parent == \"number\") throw new Error(\"!\")\n    if (!this.nodes[node.type.name]) throw new Error(\"Token type `\" + node.type.name + \"` not supported by Markdown renderer\")\n    this.nodes[node.type.name](this, node, parent, index)\n  }\n\n  // :: (Node)\n  // Render the contents of `parent` as block nodes.\n  renderContent(parent) {\n    parent.forEach((node, _, i) => this.render(node, parent, i))\n  }\n\n  // :: (Node)\n  // Render the contents of `parent` as inline content.\n  renderInline(parent) {\n    let active = [], trailing = \"\"\n    let progress = (node, _, index) => {\n      let marks = node ? node.marks : []\n\n      // Remove marks from `hard_break` that are the last node inside\n      // that mark to prevent parser edge cases with new lines just\n      // before closing marks.\n      // (FIXME it'd be nice if we had a schema-agnostic way to\n      // identify nodes that serialize as hard breaks)\n      if (node && node.type.name === \"hard_break\")\n        marks = marks.filter(m => {\n          if (index + 1 == parent.childCount) return false\n          let next = parent.child(index + 1)\n          return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text))\n        })\n\n      let leading = trailing\n      trailing = \"\"\n      // If whitespace has to be expelled from the node, adjust\n      // leading and trailing accordingly.\n      if (node && node.isText && marks.some(mark => {\n        let info = this.marks[mark.type.name]\n        return info && info.expelEnclosingWhitespace\n      })) {\n        let [_, lead, inner, trail] = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text)\n        leading += lead\n        trailing = trail\n        if (lead || trail) {\n          node = inner ? node.withText(inner) : null\n          if (!node) marks = active\n        }\n      }\n\n      let inner = marks.length && marks[marks.length - 1], noEsc = inner && this.marks[inner.type.name].escape === false\n      let len = marks.length - (noEsc ? 1 : 0)\n\n      // Try to reorder 'mixable' marks, such as em and strong, which\n      // in Markdown may be opened and closed in different order, so\n      // that order of the marks for the token matches the order in\n      // active.\n      outer: for (let i = 0; i < len; i++) {\n        let mark = marks[i]\n        if (!this.marks[mark.type.name].mixable) break\n        for (let j = 0; j < active.length; j++) {\n          let other = active[j]\n          if (!this.marks[other.type.name].mixable) break\n          if (mark.eq(other)) {\n            if (i > j)\n              marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len))\n            else if (j > i)\n              marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len))\n            continue outer\n          }\n        }\n      }\n\n      // Find the prefix of the mark set that didn't change\n      let keep = 0\n      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) ++keep\n\n      // Close the marks that need to be closed\n      while (keep < active.length)\n        this.text(this.markString(active.pop(), false, parent, index), false)\n\n      // Output any previously expelled trailing whitespace outside the marks\n      if (leading) this.text(leading)\n\n      // Open the marks that need to be opened\n      if (node) {\n        while (active.length < len) {\n          let add = marks[active.length]\n          active.push(add)\n          this.text(this.markString(add, true, parent, index), false)\n        }\n\n        // Render the node. Special case code marks, since their content\n        // may not be escaped.\n        if (noEsc && node.isText)\n          this.text(this.markString(inner, true, parent, index) + node.text +\n                    this.markString(inner, false, parent, index + 1), false)\n        else\n          this.render(node, parent, index)\n      }\n    }\n    parent.forEach(progress)\n    progress(null, null, parent.childCount)\n  }\n\n  // :: (Node, string, (number) → string)\n  // Render a node's content as a list. `delim` should be the extra\n  // indentation added to all lines except the first in an item,\n  // `firstDelim` is a function going from an item index to a\n  // delimiter for the first line of the item.\n  renderList(node, delim, firstDelim) {\n    if (this.closed && this.closed.type == node.type)\n      this.flushClose(3)\n    else if (this.inTightList)\n      this.flushClose(1)\n\n    let isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists\n    let prevTight = this.inTightList\n    this.inTightList = isTight\n    node.forEach((child, _, i) => {\n      if (i && isTight) this.flushClose(1)\n      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i))\n    })\n    this.inTightList = prevTight\n  }\n\n  // :: (string, ?bool) → string\n  // Escape the given string so that it can safely appear in Markdown\n  // content. If `startOfLine` is true, also escape characters that\n  // have special meaning only at the start of the line.\n  esc(str, startOfLine) {\n    str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\")\n    if (startOfLine) str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\s*\\d+)\\./, \"$1\\\\.\")\n    return str\n  }\n\n  quote(str) {\n    var wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\"\n    return wrap[0] + str + wrap[1]\n  }\n\n  // :: (string, number) → string\n  // Repeat the given string `n` times.\n  repeat(str, n) {\n    let out = \"\"\n    for (let i = 0; i < n; i++) out += str\n    return out\n  }\n\n  // : (Mark, bool, string?) → string\n  // Get the markdown string for a given opening or closing mark.\n  markString(mark, open, parent, index) {\n    let info = this.marks[mark.type.name]\n    let value = open ? info.open : info.close\n    return typeof value == \"string\" ? value : value(this, mark, parent, index)\n  }\n\n  // :: (string) → { leading: ?string, trailing: ?string }\n  // Get leading and trailing whitespace from a string. Values of\n  // leading or trailing property of the return object will be undefined\n  // if there is no match.\n  getEnclosingWhitespace(text) {\n    return {\n      leading: (text.match(/^(\\s+)/) || [])[0],\n      trailing: (text.match(/(\\s+)$/) || [])[0]\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}