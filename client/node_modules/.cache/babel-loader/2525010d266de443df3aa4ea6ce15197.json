{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst prosemirror_commands_1 = require(\"prosemirror-commands\");\n\nconst prosemirror_state_1 = require(\"prosemirror-state\");\n\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\n\nconst Mark_1 = __importDefault(require(\"./Mark\"));\n\nconst isModKey_1 = __importDefault(require(\"../lib/isModKey\"));\n\nconst LINK_INPUT_REGEX = /\\[(.+)]\\((\\S+)\\)/;\n\nfunction isPlainURL(link, parent, index, side) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n    return false;\n  }\n\n  const content = parent.child(index + (side < 0 ? -1 : 0));\n\n  if (!content.isText || content.text !== link.attrs.href || content.marks[content.marks.length - 1] !== link) {\n    return false;\n  }\n\n  if (index === (side < 0 ? 1 : parent.childCount - 1)) {\n    return true;\n  }\n\n  const next = parent.child(index + (side < 0 ? -2 : 1));\n  return !link.isInSet(next.marks);\n}\n\nclass Link extends Mark_1.default {\n  get name() {\n    return \"link\";\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        href: {\n          default: \"\"\n        }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: \"a[href]\",\n        getAttrs: dom => ({\n          href: dom.getAttribute(\"href\")\n        })\n      }],\n      toDOM: node => [\"a\", Object.assign(Object.assign({}, node.attrs), {\n        rel: \"noopener noreferrer nofollow\"\n      }), 0]\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [new prosemirror_inputrules_1.InputRule(LINK_INPUT_REGEX, (state, match, start, end) => {\n      const [okay, alt, href] = match;\n      const {\n        tr\n      } = state;\n\n      if (okay) {\n        tr.replaceWith(start, end, this.editor.schema.text(alt)).addMark(start, start + alt.length, type.create({\n          href\n        }));\n      }\n\n      return tr;\n    })];\n  }\n\n  commands({\n    type\n  }) {\n    return ({\n      href\n    } = {\n      href: \"\"\n    }) => prosemirror_commands_1.toggleMark(type, {\n      href\n    });\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      \"Mod-k\": (state, dispatch) => {\n        if (state.selection.empty) {\n          this.options.onKeyboardShortcut();\n          return true;\n        }\n\n        return prosemirror_commands_1.toggleMark(type, {\n          href: \"\"\n        })(state, dispatch);\n      }\n    };\n  }\n\n  get plugins() {\n    return [new prosemirror_state_1.Plugin({\n      props: {\n        handleDOMEvents: {\n          mouseover: (view, event) => {\n            if (event.target instanceof HTMLAnchorElement && !event.target.className.includes(\"ProseMirror-widget\")) {\n              if (this.options.onHoverLink) {\n                return this.options.onHoverLink(event);\n              }\n            }\n\n            return false;\n          },\n          click: (view, event) => {\n            if (view.props.editable && view.props.editable(view.state) && !isModKey_1.default(event)) {\n              return false;\n            }\n\n            if (event.target instanceof HTMLAnchorElement) {\n              const href = event.target.href || (event.target.parentNode instanceof HTMLAnchorElement ? event.target.parentNode.href : \"\");\n              const isHashtag = href.startsWith(\"#\");\n\n              if (isHashtag && this.options.onClickHashtag) {\n                event.stopPropagation();\n                event.preventDefault();\n                this.options.onClickHashtag(href, event);\n                return true;\n              }\n\n              if (this.options.onClickLink) {\n                event.stopPropagation();\n                event.preventDefault();\n                this.options.onClickLink(href, event);\n                return true;\n              }\n            }\n\n            return false;\n          }\n        }\n      }\n    })];\n  }\n\n  get toMarkdown() {\n    return {\n      open(_state, mark, parent, index) {\n        return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n      },\n\n      close(state, mark, parent, index) {\n        return isPlainURL(mark, parent, index, -1) ? \">\" : \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\";\n      }\n\n    };\n  }\n\n  parseMarkdown() {\n    return {\n      mark: \"link\",\n      getAttrs: tok => ({\n        href: tok.attrGet(\"href\"),\n        title: tok.attrGet(\"title\") || null\n      })\n    };\n  }\n\n}\n\nexports.default = Link;","map":{"version":3,"sources":["../../src/marks/Link.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_commands_1 = require(\"prosemirror-commands\");\nconst prosemirror_state_1 = require(\"prosemirror-state\");\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\nconst Mark_1 = __importDefault(require(\"./Mark\"));\nconst isModKey_1 = __importDefault(require(\"../lib/isModKey\"));\nconst LINK_INPUT_REGEX = /\\[(.+)]\\((\\S+)\\)/;\nfunction isPlainURL(link, parent, index, side) {\n    if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n        return false;\n    }\n    const content = parent.child(index + (side < 0 ? -1 : 0));\n    if (!content.isText ||\n        content.text !== link.attrs.href ||\n        content.marks[content.marks.length - 1] !== link) {\n        return false;\n    }\n    if (index === (side < 0 ? 1 : parent.childCount - 1)) {\n        return true;\n    }\n    const next = parent.child(index + (side < 0 ? -2 : 1));\n    return !link.isInSet(next.marks);\n}\nclass Link extends Mark_1.default {\n    get name() {\n        return \"link\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                href: {\n                    default: \"\",\n                },\n            },\n            inclusive: false,\n            parseDOM: [\n                {\n                    tag: \"a[href]\",\n                    getAttrs: (dom) => ({\n                        href: dom.getAttribute(\"href\"),\n                    }),\n                },\n            ],\n            toDOM: node => [\n                \"a\",\n                Object.assign(Object.assign({}, node.attrs), { rel: \"noopener noreferrer nofollow\" }),\n                0,\n            ],\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(LINK_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, alt, href] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start, end, this.editor.schema.text(alt)).addMark(start, start + alt.length, type.create({ href }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    commands({ type }) {\n        return ({ href } = { href: \"\" }) => prosemirror_commands_1.toggleMark(type, { href });\n    }\n    keys({ type }) {\n        return {\n            \"Mod-k\": (state, dispatch) => {\n                if (state.selection.empty) {\n                    this.options.onKeyboardShortcut();\n                    return true;\n                }\n                return prosemirror_commands_1.toggleMark(type, { href: \"\" })(state, dispatch);\n            },\n        };\n    }\n    get plugins() {\n        return [\n            new prosemirror_state_1.Plugin({\n                props: {\n                    handleDOMEvents: {\n                        mouseover: (view, event) => {\n                            if (event.target instanceof HTMLAnchorElement &&\n                                !event.target.className.includes(\"ProseMirror-widget\")) {\n                                if (this.options.onHoverLink) {\n                                    return this.options.onHoverLink(event);\n                                }\n                            }\n                            return false;\n                        },\n                        click: (view, event) => {\n                            if (view.props.editable &&\n                                view.props.editable(view.state) &&\n                                !isModKey_1.default(event)) {\n                                return false;\n                            }\n                            if (event.target instanceof HTMLAnchorElement) {\n                                const href = event.target.href ||\n                                    (event.target.parentNode instanceof HTMLAnchorElement\n                                        ? event.target.parentNode.href\n                                        : \"\");\n                                const isHashtag = href.startsWith(\"#\");\n                                if (isHashtag && this.options.onClickHashtag) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickHashtag(href, event);\n                                    return true;\n                                }\n                                if (this.options.onClickLink) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickLink(href, event);\n                                    return true;\n                                }\n                            }\n                            return false;\n                        },\n                    },\n                },\n            }),\n        ];\n    }\n    get toMarkdown() {\n        return {\n            open(_state, mark, parent, index) {\n                return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n            },\n            close(state, mark, parent, index) {\n                return isPlainURL(mark, parent, index, -1)\n                    ? \">\"\n                    : \"](\" +\n                        state.esc(mark.attrs.href) +\n                        (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") +\n                        \")\";\n            },\n        };\n    }\n    parseMarkdown() {\n        return {\n            mark: \"link\",\n            getAttrs: tok => ({\n                href: tok.attrGet(\"href\"),\n                title: tok.attrGet(\"title\") || null,\n            }),\n        };\n    }\n}\nexports.default = Link;\n//# sourceMappingURL=Link.js.map"]},"metadata":{},"sourceType":"script"}