{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\n\nconst Node_1 = __importDefault(require(\"./Node\"));\n\nclass HorizontalRule extends Node_1.default {\n  get name() {\n    return \"hr\";\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        markup: {\n          default: \"---\"\n        }\n      },\n      group: \"block\",\n      parseDOM: [{\n        tag: \"hr\"\n      }],\n      toDOM: node => {\n        return [\"hr\", {\n          class: node.attrs.markup === \"***\" ? \"page-break\" : \"\"\n        }];\n      }\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return attrs => (state, dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create(attrs)).scrollIntoView());\n      return true;\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      \"Mod-_\": (state, dispatch) => {\n        dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n        return true;\n      }\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [new prosemirror_inputrules_1.InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n      const {\n        tr\n      } = state;\n\n      if (match[0]) {\n        const markup = match[0].trim();\n        tr.replaceWith(start - 1, end, type.create({\n          markup\n        }));\n      }\n\n      return tr;\n    })];\n  }\n\n  toMarkdown(state, node) {\n    state.write(`\\n${node.attrs.markup}`);\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"hr\",\n      getAttrs: tok => ({\n        markup: tok.markup\n      })\n    };\n  }\n\n}\n\nexports.default = HorizontalRule;","map":{"version":3,"sources":["../../src/nodes/HorizontalRule.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AAEA,MAAqB,cAArB,SAA4C,MAAA,CAAA,OAA5C,CAAgD;AACtC,MAAJ,IAAI,GAAA;AACN,WAAO,IAAP;AACD;;AAES,MAAN,MAAM,GAAA;AACR,WAAO;AACL,MAAA,KAAK,EAAE;AACL,QAAA,MAAM,EAAE;AACN,UAAA,OAAO,EAAE;AADH;AADH,OADF;AAML,MAAA,KAAK,EAAE,OANF;AAOL,MAAA,QAAQ,EAAE,CAAC;AAAE,QAAA,GAAG,EAAE;AAAP,OAAD,CAPL;AAQL,MAAA,KAAK,EAAE,IAAI,IAAG;AACZ,eAAO,CACL,IADK,EAEL;AAAE,UAAA,KAAK,EAAE,IAAI,CAAC,KAAL,CAAW,MAAX,KAAsB,KAAtB,GAA8B,YAA9B,GAA6C;AAAtD,SAFK,CAAP;AAID;AAbI,KAAP;AAeD;;AAED,EAAA,QAAQ,CAAC;AAAE,IAAA;AAAF,GAAD,EAAS;AACf,WAAO,KAAK,IAAI,CAAC,KAAD,EAAQ,QAAR,KAAoB;AAClC,MAAA,QAAQ,CACN,KAAK,CAAC,EAAN,CAAS,oBAAT,CAA8B,IAAI,CAAC,MAAL,CAAY,KAAZ,CAA9B,EAAkD,cAAlD,EADM,CAAR;AAGA,aAAO,IAAP;AACD,KALD;AAMD;;AAED,EAAA,IAAI,CAAC;AAAE,IAAA;AAAF,GAAD,EAAS;AACX,WAAO;AACL,eAAS,CAAC,KAAD,EAAQ,QAAR,KAAoB;AAC3B,QAAA,QAAQ,CAAC,KAAK,CAAC,EAAN,CAAS,oBAAT,CAA8B,IAAI,CAAC,MAAL,EAA9B,EAA6C,cAA7C,EAAD,CAAR;AACA,eAAO,IAAP;AACD;AAJI,KAAP;AAMD;;AAED,EAAA,UAAU,CAAC;AAAE,IAAA;AAAF,GAAD,EAAS;AACjB,WAAO,CACL,IAAI,wBAAA,CAAA,SAAJ,CAAc,0BAAd,EAA0C,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,GAAtB,KAA6B;AACrE,YAAM;AAAE,QAAA;AAAF,UAAS,KAAf;;AAEA,UAAI,KAAK,CAAC,CAAD,CAAT,EAAc;AACZ,cAAM,MAAM,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,EAAf;AACA,QAAA,EAAE,CAAC,WAAH,CAAe,KAAK,GAAG,CAAvB,EAA0B,GAA1B,EAA+B,IAAI,CAAC,MAAL,CAAY;AAAE,UAAA;AAAF,SAAZ,CAA/B;AACD;;AAED,aAAO,EAAP;AACD,KATD,CADK,CAAP;AAYD;;AAED,EAAA,UAAU,CAAC,KAAD,EAAQ,IAAR,EAAY;AACpB,IAAA,KAAK,CAAC,KAAN,CAAY,KAAK,IAAI,CAAC,KAAL,CAAW,MAAM,EAAlC;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,IAAjB;AACD;;AAED,EAAA,aAAa,GAAA;AACX,WAAO;AACL,MAAA,IAAI,EAAE,IADD;AAEL,MAAA,QAAQ,EAAE,GAAG,KAAK;AAChB,QAAA,MAAM,EAAE,GAAG,CAAC;AADI,OAAL;AAFR,KAAP;AAMD;;AApE6C;;AAAhD,OAAA,CAAA,OAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_inputrules_1 = require(\"prosemirror-inputrules\");\nconst Node_1 = __importDefault(require(\"./Node\"));\nclass HorizontalRule extends Node_1.default {\n    get name() {\n        return \"hr\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                markup: {\n                    default: \"---\",\n                },\n            },\n            group: \"block\",\n            parseDOM: [{ tag: \"hr\" }],\n            toDOM: node => {\n                return [\n                    \"hr\",\n                    { class: node.attrs.markup === \"***\" ? \"page-break\" : \"\" },\n                ];\n            },\n        };\n    }\n    commands({ type }) {\n        return attrs => (state, dispatch) => {\n            dispatch(state.tr.replaceSelectionWith(type.create(attrs)).scrollIntoView());\n            return true;\n        };\n    }\n    keys({ type }) {\n        return {\n            \"Mod-_\": (state, dispatch) => {\n                dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n                return true;\n            },\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n                const { tr } = state;\n                if (match[0]) {\n                    const markup = match[0].trim();\n                    tr.replaceWith(start - 1, end, type.create({ markup }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    toMarkdown(state, node) {\n        state.write(`\\n${node.attrs.markup}`);\n        state.closeBlock(node);\n    }\n    parseMarkdown() {\n        return {\n            node: \"hr\",\n            getAttrs: tok => ({\n                markup: tok.markup,\n            }),\n        };\n    }\n}\nexports.default = HorizontalRule;\n//# sourceMappingURL=HorizontalRule.js.map"]},"metadata":{},"sourceType":"script"}