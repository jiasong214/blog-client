{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst token_1 = __importDefault(require(\"markdown-it/lib/token\"));\n\nconst BREAK_REGEX = /(?:^|[^\\\\])\\\\n/;\n\nfunction markdownTables(md) {\n  md.core.ruler.after(\"inline\", \"tables-pm\", state => {\n    const tokens = state.tokens;\n    let inside = false;\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      if (inside) {\n        tokens[i].level--;\n      }\n\n      if (tokens[i].type === \"inline\" && tokens[i].content.match(BREAK_REGEX)) {\n        const existing = tokens[i].children || [];\n        tokens[i].children = [];\n        existing.forEach(child => {\n          var _a;\n\n          const breakParts = child.content.split(BREAK_REGEX);\n\n          if (breakParts.length > 1 && child.type !== \"code_inline\") {\n            breakParts.forEach((part, index) => {\n              var _a, _b;\n\n              const token = new token_1.default(\"text\", \"\", 1);\n              token.content = part.trim();\n              (_a = tokens[i].children) === null || _a === void 0 ? void 0 : _a.push(token);\n\n              if (index < breakParts.length - 1) {\n                const brToken = new token_1.default(\"br\", \"br\", 1);\n                (_b = tokens[i].children) === null || _b === void 0 ? void 0 : _b.push(brToken);\n              }\n            });\n          } else {\n            (_a = tokens[i].children) === null || _a === void 0 ? void 0 : _a.push(child);\n          }\n        });\n      }\n\n      if ([\"thead_open\", \"thead_close\", \"tbody_open\", \"tbody_close\"].includes(tokens[i].type)) {\n        inside = !inside;\n        tokens.splice(i, 1);\n      }\n\n      if ([\"th_open\", \"td_open\"].includes(tokens[i].type)) {\n        tokens.splice(i + 1, 0, new token_1.default(\"paragraph_open\", \"p\", 1));\n        const tokenAttrs = tokens[i].attrs;\n\n        if (tokenAttrs) {\n          const style = tokenAttrs[0][1];\n          tokens[i].info = style.split(\":\")[1];\n        }\n      }\n\n      if ([\"th_close\", \"td_close\"].includes(tokens[i].type)) {\n        tokens.splice(i, 0, new token_1.default(\"paragraph_close\", \"p\", -1));\n      }\n    }\n\n    return false;\n  });\n}\n\nexports.default = markdownTables;","map":{"version":3,"sources":["../../../src/lib/markdown/tables.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst token_1 = __importDefault(require(\"markdown-it/lib/token\"));\nconst BREAK_REGEX = /(?:^|[^\\\\])\\\\n/;\nfunction markdownTables(md) {\n    md.core.ruler.after(\"inline\", \"tables-pm\", state => {\n        const tokens = state.tokens;\n        let inside = false;\n        for (let i = tokens.length - 1; i > 0; i--) {\n            if (inside) {\n                tokens[i].level--;\n            }\n            if (tokens[i].type === \"inline\" && tokens[i].content.match(BREAK_REGEX)) {\n                const existing = tokens[i].children || [];\n                tokens[i].children = [];\n                existing.forEach(child => {\n                    var _a;\n                    const breakParts = child.content.split(BREAK_REGEX);\n                    if (breakParts.length > 1 && child.type !== \"code_inline\") {\n                        breakParts.forEach((part, index) => {\n                            var _a, _b;\n                            const token = new token_1.default(\"text\", \"\", 1);\n                            token.content = part.trim();\n                            (_a = tokens[i].children) === null || _a === void 0 ? void 0 : _a.push(token);\n                            if (index < breakParts.length - 1) {\n                                const brToken = new token_1.default(\"br\", \"br\", 1);\n                                (_b = tokens[i].children) === null || _b === void 0 ? void 0 : _b.push(brToken);\n                            }\n                        });\n                    }\n                    else {\n                        (_a = tokens[i].children) === null || _a === void 0 ? void 0 : _a.push(child);\n                    }\n                });\n            }\n            if ([\"thead_open\", \"thead_close\", \"tbody_open\", \"tbody_close\"].includes(tokens[i].type)) {\n                inside = !inside;\n                tokens.splice(i, 1);\n            }\n            if ([\"th_open\", \"td_open\"].includes(tokens[i].type)) {\n                tokens.splice(i + 1, 0, new token_1.default(\"paragraph_open\", \"p\", 1));\n                const tokenAttrs = tokens[i].attrs;\n                if (tokenAttrs) {\n                    const style = tokenAttrs[0][1];\n                    tokens[i].info = style.split(\":\")[1];\n                }\n            }\n            if ([\"th_close\", \"td_close\"].includes(tokens[i].type)) {\n                tokens.splice(i, 0, new token_1.default(\"paragraph_close\", \"p\", -1));\n            }\n        }\n        return false;\n    });\n}\nexports.default = markdownTables;\n//# sourceMappingURL=tables.js.map"]},"metadata":{},"sourceType":"script"}