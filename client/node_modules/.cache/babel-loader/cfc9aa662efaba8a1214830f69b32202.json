{"ast":null,"code":"// Process block-level custom containers\n//\n'use strict';\n\nmodule.exports = function container_plugin(md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params\n  /*, markup*/\n  ) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n  var min_markers = 3,\n      marker_str = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len = marker_str.length,\n      validate = options.validate || validateDefault,\n      render = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        markup,\n        params,\n        token,\n        old_parent,\n        old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine]; // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    } // Check out the rest of the marker string\n    //\n\n\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n\n    pos -= (pos - start) % marker_len;\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n\n    if (!validate(params, markup)) {\n      return false;\n    } // Since start is found, we can report success here in validation mode\n    //\n\n\n    if (silent) {\n      return true;\n    } // Search for the end of the block\n    //\n\n\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      } // closing code fence must be at least as long as the opening one\n\n\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      } // make sure tail has spaces only\n\n\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      } // found!\n\n\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container'; // this will prevent lazy continuations from ever going past our end marker\n\n    state.lineMax = nextLine;\n    token = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block = true;\n    token.info = params;\n    token.map = [startLine, nextLine];\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    token = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};","map":{"version":3,"sources":["/Users/jia/Desktop/Portfolio/personal-blog/client/node_modules/markdown-it-container/index.js"],"names":["module","exports","container_plugin","md","name","options","validateDefault","params","trim","split","renderDefault","tokens","idx","_options","env","slf","nesting","attrJoin","renderToken","min_markers","marker_str","marker","marker_char","charCodeAt","marker_len","length","validate","render","container","state","startLine","endLine","silent","pos","nextLine","marker_count","markup","token","old_parent","old_line_max","auto_closed","start","bMarks","tShift","max","eMarks","src","Math","floor","slice","sCount","blkIndent","skipSpaces","parentType","lineMax","push","block","info","map","tokenize","line","ruler","before","alt","renderer","rules"],"mappings":"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","sourcesContent":["// Process block-level custom containers\n//\n'use strict';\n\n\nmodule.exports = function container_plugin(md, name, options) {\n\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params/*, markup*/) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n\n  var min_markers = 3,\n      marker_str  = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length,\n      validate    = options.validate || validateDefault,\n      render      = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, params, token,\n        old_parent, old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n    if (!validate(params, markup)) { return false; }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block  = true;\n    token.info   = params;\n    token.map    = [ startLine, nextLine ];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token        = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block  = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};\n"]},"metadata":{},"sourceType":"script"}